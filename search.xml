<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>从理论到实践，全方位认识DNS（实践篇）</title>
      <link href="/2019/09/17/cong-li-lun-dao-shi-jian-quan-fang-wei-ren-shi-dns-shi-jian-pian/"/>
      <url>/2019/09/17/cong-li-lun-dao-shi-jian-quan-fang-wei-ren-shi-dns-shi-jian-pian/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div align="middle">        <div id="aplayer-FfDzhOQG" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;width:40%;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-FfDzhOQG"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "阴天",              author: "莫文蔚",              url: "http://fs.open.kugou.com/1e4bc7810ce34dc85db25b34544a6f6a/5d803749/G007/M02/0E/19/Rw0DAFS4JEiAaGu0ADs4r5osaCc324.mp3",              pic: "http://imge.kugou.com/stdmusic/150/20150714/20150714151212165910.jpg",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script></div><blockquote><p>作者：selfboot<br>链接：<a href="http://selfboot.cn/2015/11/05/dns_theory/" target="_blank" rel="noopener">http://selfboot.cn/2015/11/05/dns_theory/</a></p></blockquote><p>在<a href="https://cchblog.cn/2019/09/15/cong-li-lun-dao-shi-jian-quan-fang-wei-ren-shi-dns-li-lun-pian/">理论篇</a>我们基本了解了DNS的整个协议原理，但是可能还会有着下面的疑问：</p><ol><li>为什么我想申请的域名都没了？</li><li>DNS 域名还要备案，这是为什么啊？</li><li>如何将刚申请的域名绑定到自己的网站呢？</li><li>怎么才能看到那些在背后默默给我解析的域名服务器呢？</li><li>他们说用一个什么文件就可以访问好多好多不存在的网站，是真的吗？</li><li>可信任的域名服务器是怎么一回事，难道有些域名服务器会做坏事？</li><li>怎么知道我现在用的域名服务器有没有使坏呢？</li><li>……</li></ol><h1 id="域名注册、绑定"><a href="#域名注册、绑定" class="headerlink" title="域名注册、绑定"></a>域名注册、绑定</h1><hr><p>首先明确一点，每个人都可以去注册域名。大多数时候我们希望去注册一个顶级域名（比如selfboot.cn, google.com等），那些二级域名毕竟不够好记（比如github托管博客的域名：username.github.io）。有的顶级域名（比如<a href="http://www.dot.tk/zh/index.html?lang=zh" target="_blank" rel="noopener">.tk</a>域名）提供免费的一年域名试用，不过绝大多时候还是要为自己的域名付费的（一般是按年付费，也不是很贵）。要想去注册域名，首先得找到域名注册商，国内的比较著名的有DNSpod等，国外的有godaddy等。相信注册过域名的人都知道绝大多数我们能想到的自己喜欢的域名都已名花有主了，只剩那些不是那么惹人关注的域名供我们选择。所以，注册域名时，发现自己每想到一个域名都显示被人注册后，那太正常不过了，说明你的品味比较正常。</p><p>这里一点个人建议，选中一个域名后不要轻易去改了，因为换域名成本挺高的（我猜现在就算给淘宝一千万，它也不会换另成一个域名吧）。所以，最好不要去用免费的域名，因为指不定啥时候就不让你用了。你应该相信这么一个观点：<strong>天下没有免费的午餐</strong>。拓展一下就是，掏钱买服务，心里踏实。</p><p>接下来你可能会希望将自己的站点或者博客挂在自己选中的域名下，这其实很简单，只需要找到一个提供域名解析的服务商，然后填写相应的域名解析记录。大多时候，你注册域名的服务商都会免费提供域名解析服务。</p><p>现实中，大部分人可能会拥有个人博客，以前我们都是依赖一个博客平台（如CSDN），或者是买一台VPS托管自己的博客。不过自从Github推出了Blog服务，好多程序员都转而将博客托管在上面。Github Blog支持绑定个人域名，并提供了详细的绑定文档：<a href="https://help.github.com/en/articles/adding-or-removing-a-custom-domain-for-your-github-pages-site" target="_blank" rel="noopener">Adding a CNAME file to your repository</a>。假设你的博客已经可以通过 username.github.io 访问，接下来只需要用 CNAME 告诉Github你的博客绑定了哪个域名（比如说是selfboot.cn），然后在域名解析商那里添加解析记录即可，下图是我个人博客在DNSpod的解析记录：<br><img src="1.png" alt="域名解析记录"></p><p>现在当我们访问 selfboot.cn 时，DNSpod就会将请求解析到 Github 提供的 IP 地址上。之后 Github 上面的博客托管服务器在所有用户的 CNAME 记录中，找到本次请求的域名对应的博客项目地址，比如说是 xuelangZF.github.io，然后返回博客内容。</p><h1 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h1><hr><p>我们都知道一个域名的解析过程中，可能会有多台域名服务器给我们帮助，那么我们怎么能看到这些背后的功臣呢？先介绍两个常用的关于DNS的命令。</p><h2 id="dig-nslookup"><a href="#dig-nslookup" class="headerlink" title="dig, nslookup"></a>dig, nslookup</h2><hr><p><code>dig</code> (Domain Information Groper), 是 UNIX/BSD 系统自带的 DNS 诊断工具，使用十分灵活、方便。</p><p>查询 selfboot.cn 的A记录，并返回简短的结果：</p><pre><code>$ dig selfboot.cn -t A +short192.30.252.153192.30.252.154</code></pre><p>用 dig 还可以查询某一 ip 对应的域名，如下：</p><pre><code>$ dig -x 192.30.252.153 +shortpages.github.com.</code></pre><p>这里返回的是pages.github.com，因为当你访问博客地址 selfboot.cn 时，其实是Github的pages 服务器（域名是：pages.github.com）在后台返回该博客内容的（根据 CNAME 确定返回哪个博客）。</p><p>nslookup 也是一个 DNS 诊断工具，几乎所有平台都自带该工具，使用也很简答，可以用 man 查询手册。</p><h2 id="解析路径查询"><a href="#解析路径查询" class="headerlink" title="解析路径查询"></a>解析路径查询</h2><hr><p>接下来用 dig 命令查看从根域名到指定域名中间可能经过的所有域名服务器，使用 <code>+trace</code> 选项即可。</p><pre><code>dig selfboot.cn +trace @8.8.8.8; &lt;&lt;&gt;&gt; DiG 9.8.3-P1 &lt;&lt;&gt;&gt; selfboot.cn +trace @8.8.8.8;; global options: +cmd.            474418    IN    NS    j.root-servers.net..            474418    IN    NS    g.root-servers.net........            474418    IN    NS    l.root-servers.net..            474418    IN    NS    m.root-servers.net.;; Received 496 bytes from 8.8.8.8#53(8.8.8.8) in 12 mscn.            172800    IN    NS    a.dns.cn.......cn.            172800    IN    NS    e.dns.cn.cn.            172800    IN    NS    ns.cernet.net.;; Received 292 bytes from 2001:500:1::803f:235#53(2001:500:1::803f:235) in 382 msselfboot.cn.        86400    IN    NS    f1g1ns2.dnspod.net.selfboot.cn.        86400    IN    NS    f1g1ns1.dnspod.net.;; Received 83 bytes from 203.119.25.1#53(203.119.25.1) in 816 msselfboot.cn.        14400    IN    A    192.30.252.153selfboot.cn.        14400    IN    A    192.30.252.154selfboot.cn.        600    IN    NS    f1g1ns1.dnspod.net.selfboot.cn.        600    IN    NS    f1g1ns2.dnspod.net.;; Received 125 bytes from 115.236.137.40#53(115.236.137.40) in 31 ms</code></pre><p>可以看到最开始是13台顶级域名服务器的NS记录（中间省去一些记录减少行数，方便观察更清楚），接下来是顶级域名 cn. 的权威域名服务器（省略一些输出），然后是 selfboot.cn 的 NS 记录，即 DNSpod 的两条 NS 记录，最后从 f1g1ns2.dnspod.net 找到 selfboot.cn 的 A 记录。</p><p><a href="https://github.com/seveas" target="_blank" rel="noopener">seveas</a> 提供了一个可视化的路径查询工具：<a href="http://ip.seveas.net/dnsgraph/" target="_blank" rel="noopener">dnsgraph</a>，可以在线绘制跟域名到指定域名的所有可能路径。</p><p>当然，实际查询过程中，大多时候我们在本地缓存或者本地域名服务器缓存就能直接找到需要的域名记录，不需要每次都向根域名服务器发起请求，然后重复迭代或者递归查询过程。</p><h1 id="DNS-缺陷"><a href="#DNS-缺陷" class="headerlink" title="DNS 缺陷"></a>DNS 缺陷</h1><p>域名系统设计的很理想很美好，然而仍有一些小的瑕疵，可能会给我们带来些许困扰。</p><h2 id="域名抢注"><a href="#域名抢注" class="headerlink" title="域名抢注"></a>域名抢注</h2><p>首先，有些域名对注册人没有限制，而另外一些域名则对谁可以得到一个域名空间中的名字有限制。比如pro域名是分配给合适的专业人员，但问题是谁才是专业的呢？显然医生、工程师是专业人员，但理发师、管道工呢？</p><p>此外，域名也可以被倒卖。黄牛们会批量注册大量域名（据说com域名下几乎每一个普通词都被人尝试注册了域名），然后转身就以高价转卖给那些对该域名感兴趣的人，这就是所谓的域名抢注。所以，现在你想注册一个符合自己网站特点的域名是很难的。</p><p>这个问题其实还不算严重，更要命的是下面两个问题。</p><h2 id="DNS-劫持"><a href="#DNS-劫持" class="headerlink" title="DNS 劫持"></a>DNS 劫持</h2><p>我们知道一个域名服务器对其区域内的用户解析请求负责，但是并没有一个机制去监督它有没有真地负责。也就是说域名服务器的权力并没有被关在笼子里，所以它既可以认真地“为人民服务”，也可以<strong>指鹿为马</strong>。于是有些流氓的域名服务器故意更改一些域名的解析结果，将用户引向一个错误的目标地址。这就叫作 DNS 劫持，主要用来阻止用户访问某些特定的网站，或者是将用户引导到广告页面。<br><img src="2.png" alt="DNS 劫持"></p><p>下面验证下我所用的域名服务器有没有干这种坏事，只需要一条简单的命令即可：</p><pre><code>➜  ~  nslookup google.comServer:        10.8.4.4Address:    10.8.4.4#53Non-authoritative answer:Name:    google.comAddress: 120.196.0.5</code></pre><p>我的DNS服务器地址为10.8.4.4，他告诉我google.com的地址是120.196.0.5，我才不信呢。于是用<code>whois 120.196.0.5</code>一看，果真不是Google的地址。针对DNS劫持，我们可以简单地更换域名服务器，比较靠谱的一个是Google提供的8.8.8.8。下面用 8.8.8.8 来解析一下 <a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a> 就能看到正确的地址了。</p><pre><code>$ nslookup www.google.com 8.8.8.8Server:        8.8.8.8Address:    8.8.8.8#53Non-authoritative answer:Name:    www.google.comAddress: 216.58.221.68</code></pre><h2 id="DNS-欺骗"><a href="#DNS-欺骗" class="headerlink" title="DNS 欺骗"></a>DNS 欺骗</h2><p>DNS 劫持通过简单的切换域名服务器就可以绕过，不过一旦你遇上了 <code>DNS 欺骗</code>，就无法简单地绕过了。下面我们用不同的域名服务器来查看 fb 的 IP 地址，结果都返回了同一个地址，看起来好像是真的一样，不过也仅仅是看起来而已。</p><pre><code>$ nslookup facebook.comServer:        10.8.4.4Address:    10.8.4.4#53Non-authoritative answer:Name:    facebook.comAddress: 159.106.121.75$ nslookup facebook.com 8.8.8.8Server:        8.8.8.8Address:    8.8.8.8#53Non-authoritative answer:Name:    facebook.comAddress: 159.106.121.75</code></pre><p>这个地址并不是 fb 的服务器地址（可以在 ViewDNS 查询所有域名真实的域名资源记录，<a href="http://viewdns.info/dnsrecord/" target="_blank" rel="noopener">ViewDNS</a>是个很好玩的网站，里面有许多有意思的工具）。其实我Google了一下这个地址，竟然发现了一篇不错的<a href="http://ichuan.net/post/7/dns-cache-poisoning-in-china/" target="_blank" rel="noopener">译文</a>，看来这个地址早在 2011 年就有了特殊的含义（英文原文是相关阅读第一个）。</p><p>DNS 欺骗简单来说就是用一个假的 DNS 应答来欺骗用户计算机，让其相信这个假的地址，并且抛弃真正的 DNS 应答。在一台主机发出 DNS 请求后，它就开始等待应答，如果此时有一个看起来正确（拥有和DNS请求一样的序列号）的应答包，它就会信以为真，并且丢弃稍晚一点到达的应答。<br><img src="3.png" alt="DNS欺骗原理"></p><p>实施 DNS 欺骗的关键在于伪造一个有特定序列号的应答包，并且让其抢先一步到达发起请求的主机。这对于个人来说还有点难度，但是对于拥有骨干网节点的组织来说，实在是易如反掌，所以这么多网站都已沦陷。不过使用网上流传的那些 hosts文件，就可以在本机缓存许多网站的ip地址，进而可以和部分网站通信。但是通过hosts文件并不能完全 Cross the Great FireWall，因为人家还有很多其他手段。</p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 协议森林 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从理论到实践，全方位认识DNS（理论篇）</title>
      <link href="/2019/09/15/cong-li-lun-dao-shi-jian-quan-fang-wei-ren-shi-dns-li-lun-pian/"/>
      <url>/2019/09/15/cong-li-lun-dao-shi-jian-quan-fang-wei-ren-shi-dns-li-lun-pian/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div align="middle">        <div id="aplayer-mVsahUsT" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;width:40%;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-mVsahUsT"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "那女孩对我说",              author: "Uu",              url: "http://fs.open.kugou.com/a05b8ac90d4633188ec7e5f27a756978/5d7f35e8/G153/M00/0F/17/OYcBAF0KAoiAC9Z8AESDw95TEjM786.mp3",              pic: "http://imge.kugou.com/stdmusic/150/20190620/20190620220743443390.jpg",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script></div><blockquote><p>作者：selfboot<br>链接：<a href="http://selfboot.cn/2015/11/05/dns_theory/" target="_blank" rel="noopener">http://selfboot.cn/2015/11/05/dns_theory/</a></p></blockquote><h1 id="DNS源起"><a href="#DNS源起" class="headerlink" title="DNS源起"></a>DNS源起</h1><hr><p>要想访问网络上的一台计算机，我们必须要知道它的<font color="#FF0000">IP地址</font>，但是这些地址（比如243.185.187.39）只是一串数字，没有规律，因此我们很难记住。并且如果一台计算机变更IP后，它必须通知所有的人。</p><p>显然，直接使用IP地址是一个愚蠢的方案。于是人们想出了一个替代的方法，即为每一台计算机起一个名字，然后建立计算机名字到地址的一个映射关系。我们访问计算机的名字，剩下的名字到地址的转换过程则由计算机自动完成。</p><h2 id="hosts映射"><a href="#hosts映射" class="headerlink" title="hosts映射"></a>hosts映射</h2><hr><p>早期，名字到地址的转换过程十分简单。每台计算机保存一个<font color="#FF0000">hosts</font>文件，里面列出所有计算机名字和对应的IP地址，然后<font color="#FF0000">定期从一个维护此文件的站点更新里面的记录</font>。当我们访问某个计算机名字时，先在hosts文件找到对应的IP，然后就可以建立连接。<br><img src="1.png" alt="hosts 管理主机"></p><p>早期的ARPANET就是这样做的，但是随着网络规模的扩大，这种方法渐渐吃不消了。主要有以下三个原因：</p><ol><li>hosts文件变得非常大；</li><li>主机名字会冲突；</li><li>集中的维护站点会不堪重负（需要给几百万机器提供hosts文件，想想就可怕）。</li></ol><h2 id="域名系统"><a href="#域名系统" class="headerlink" title="域名系统"></a>域名系统</h2><hr><p>为了解决上面的问题，1983年Paul Mockapetris提出了域名系统（DNS, Domain Name System)，这是一种<strong>层次的、基于域</strong>的命名方案，并且用一个分布式数据库系统加以实现。当我们需要访问一个域名（其实就是前面说的计算机的名字）时，应用程序会向DNS服务器发起一个DNS请求，DNS服务器返回该域名对应的IP地址。通过下面三种手段解决了上面的问题：</p><ol><li>用户计算机上并没有存储所有的名字到IP的映射，这样避免了hosts文件过于庞大（现在各操作系统中hosts文件默认都是空的）。</li><li>规定了域名的命名规则，保证主机名字不会重复。</li><li>DNS服务器不再是单一的一台机器，而是一个层次的、合理组织的服务器集群。</li></ol><p>这样访问一个域名的过程可以简化为下图：<br><img src="2.png" alt="域名hosts解析过程"></p><h1 id="DNS-协议"><a href="#DNS-协议" class="headerlink" title="DNS 协议"></a>DNS 协议</h1><hr><p>那么如何具体实现这个所谓的域名系统呢，要知道管理一个超大型并且不断变化的域名到IP的映射集合可不是一个简单的事，况且还要去应付成千上万的DNS查询请求。人们最终想出了一套不错的协议，规定如何来实现这个系统，下面我们一起来看看吧。</p><h2 id="域名空间"><a href="#域名空间" class="headerlink" title="域名空间"></a>域名空间</h2><hr><p>首先我们需要制定一套命名规则，防止域名出现重复。DNS关于域名的规则和我们生活中的快递系统类似，使用层次的地址结构。快递系统中要给某人邮寄物品，地址可能是这样：中国、广东省、广州市、番禺区、中山西路12号 XXX。而一个域名看起来则是这样的groups.google.com（为什么不是com.google.groups？我猜可能和老外写地址的习惯有关）。</p><p>对于Internet来说，域名层次结构的顶级（相当于国际快递地址中的国家部分）由ICANN（互联网名称与数字地址分配机构）负责管理。目前，已经有超过250个顶级域名，每个顶级域名可以进一步划为一些子域（二级域名），这些子域可被再次划分（三级域名），依此类推。所有这些域名可以组织成一棵树，如下图所示（图片来自Computer Networks: 7-1 ）：<br><img src="3.png" alt="域名空间树"></p><h2 id="域名资源记录"><a href="#域名资源记录" class="headerlink" title="域名资源记录"></a>域名资源记录</h2><hr><p>DNS设计之初是用来建立域名到IP地址的映射，理论上对于每一个域名我们只需要在域名服务器上保存一条记录即可。这里的记录一般叫作域名资源记录，它是一个五元组，可以用以下格式表示：<br><code>Domain_name Time_to_live Class Type Value</code></p><p>其中：</p><ol><li>Domain_name: 指出这条记录适用于哪个域名；</li><li><code>Time_to_live</code>: 用来表明记录的生存周期，也就是说最多可以缓存该记录多长时间（后面会讲到缓存机制）；</li><li>Class: 一般总是IN；</li><li>Type: 记录的类型；</li><li>Value: 记录的值，如果是A记录，则value是一个IPv4地址。</li></ol><p>我们看到域名资源记录有一个Type字段，用来表明记录的类型。这是为什么呢？因为对于一个域名来说，通常并非只记录其IP地址，还可能需要一些其他种类的记录，一些常见的记录类型如下：</p><table><thead><tr><th><strong>记录类型</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>A</td><td>主机的IPv4地址</td></tr><tr><td>AAAA</td><td>主机的IPv6地址</td></tr><tr><td>NS</td><td>该域名所在域的权威域名服务器</td></tr><tr><td>MX</td><td>接受特定域名电子邮件的服务器域名</td></tr><tr><td>CNAME</td><td>当前域名的一个别名</td></tr><tr><td>关于这些域名资源记录的实例我们将在下一篇文章（实践篇）看到。</td><td></td></tr></tbody></table><h2 id="域名服务器"><a href="#域名服务器" class="headerlink" title="域名服务器"></a>域名服务器</h2><p>我们知道不能只用一台域名服务器来响应所有的DNS查询，因为没有一台机器能够给全球的用户提供查询服务，计算能力、存储、带宽都不允许。只能合理组织一个域名服务器集群，使他们协同工作，共同提供域名解析服务。接下来首先要面对的一个问题是<strong>如何合理地将所有的域名资源记录存储到不同的域名服务器上</strong>。<br>域名划分<br>前面说过域名的名字空间可以组织为一棵树，这里我们可以进一步将其划分为不重叠的区域（DNS zone），针对上图的域名空间，一种可能的域名划分如下图：<br><img src="4.png" alt="域名划分"></p><p>然后将每个区域与多个域名服务器（其中一个是master，其他slave服务器则用来提供数据备份、加快解析速度、保证服务可用性）关联起来，称这些域名服务器为该区域的<code>权威域名服务器(Authoritative Name Servers )</code>，它保存两类域名资源记录：</p><ol><li>该区域内所有域名的域名资源记录。</li><li>父区域和子区域的域名服务器对应的域名资源记录（主要是NS记录）。</li></ol><p>这样，所有的域名资源记录都保存在多个域名服务器中，并且所有的域名服务器也组成了一个层次的索引结构，便于我们后面进行域名解析。下面以一个简化的域名空间为例子，说明域名资源记录是如何保存在域名服务器中的，如下图a：<br><img src="5.png" alt="域名服务器"></p><p>图中域名空间划分为A, B, C, D, E, F, G七个DNS区域，每个DNS区域都有多个权威域名服务器，这些域名服务器里面保存了许多域名解析记录。对于上图的NDS区域E来说，它的权威域名服务器里面保存的记录如图中表格所示。</p><p>仔细观察上图你可能会发现区域A、B并没有父区域，他们之间并没有一条路径连在一起。这将导致一个很麻烦的问题，那就是区域A的权威域名服务器可能根本不知道区域B的存在。认识到这一点后，你可能会想出一个很自然的解决方案，就是在A中记录B域名服务器的地址，同时在B中记录A的，这样它们两个就联系起来了。但是考虑到我们有超过250个顶级域名，这样做并不是很恰当。</p><p>而我们使用的域名系统则采用了一种更加聪明的方法，那就是引入根域名服务器，它保存了所有顶级区域的权威域名服务器记录。现在通过根域名服务器，我们可以找到所有的顶级区域的权威域名服务器，然后就可以往下一级一级找下去了。下图为全球根域名服务器的分布图，可以在这里找到。<br><img src="6.png" alt="顶级域名服务器"></p><p>现在为止，我们的权威域名服务器和根域名服务器其实组成了一个树，树根为根域名服务器，下面每个节点都是一个区域的权威域名服务器，对于图a中各个DNS区域的权威域名服务器，它们组成了下面这棵树（<strong><em>实际中，一个权威域名服务器可能保存有多个DNS区域的记录，因此权威域名服务器之间的联系并不构成一棵树。这部分的详细内容可以参考RFC 1034: 4. NAME SERVERS。下面为了容易理解，将其简化为一棵树</em></strong>）：<br><img src="7.png" alt="域名服务器树"></p><h2 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h2><hr><p>我们已经有了一个域名服务器集群，该集群合理地保存了域名空间和域名资源记录的对应关系。现在我们要做的就是发送一个DNS请求给域名服务器，然后坐等它返回正确的域名资源记录，这个过程叫作域名解析。</p><p>严格来说，域名解析的过程最早要追溯到建立网络连接。因为每当连接上网络之后，计算机会自动获得一个默认的DNS服务器，当然你也可以用自己信任的DNS服务器，比如8.8.8.8（DNS服务器也有信任不信任之分，是的，实践篇会讲到），我们把这个域名服务器也叫作<code>本地域名服务器</code>。接下来当我们需要知道一个域名对应的资源记录时，会向本地域名服务器发起请求，如果该域名恰好在本地域名服务器所辖属的域名区域（DNS zone）内，那么可以直接返回记录。</p><p>如果在本地域名服务器没有发现该域名的资源记录，就需要在整个域名空间搜索该域名。而整个域名空间的资源记录存储在一个分层的、树状联系的一系列域名服务器上，所以本地域名服务器首先要从根域名服务器开始往下搜索。这里有一个问题就是<strong>本地域名服务器如何找到根域名服务器在哪里呢？</strong>其实域名服务器启动的时候，就会加载一个配置文件，里面保存了根域名服务器的NS记录（要知道根域名服务器地址一般非常稳定，不会轻易改变，并且数量很少，所以这个配置文件会很小）。找到根域名服务器之后，就可以一级一级地往下查找啦。</p><p>仍然以我们的图a为例，现在假设区域E内的某个用户想访问math.sysu.edu.cn，那么请求的过程如下：<br><img src="8.png" alt="域名解析过程"><br>用语言简单描述如下：</p><ol><li>用户：喂，本地域名服务器，告诉我math.sysu.edu.cn的地址；</li><li>本地域名服务器：哎呀，我不知道啊，不在我的辖区，容我去问问老大哥吧。root老大，能告诉我math.sysu.edu.cn的地址吗；</li><li>根域名服务器：忙着呢，你去问B（.cn）；</li><li>本地域名服务器：喂，B，告诉我math.sysu.edu.cn的地址；</li><li>B：你去问D（.edu.cn）；</li><li>本地域名服务器：喂，D，告诉我math.sysu.edu.cn的地址；</li><li>D：你去问F（sysu.edu.cn）；</li><li>本地域名服务器：喂，F，告诉我math.sysu.edu.cn的地址；</li><li>F：容老衲看看，哎呀，找到了，是X.X.X.X；</li><li>本地域名服务器：踏破铁鞋终于找到啦，喂用户，出来啊，我找到了，是X.X.X.X</li></ol><p>仔细想想，这和我们邮寄快递实在是如出一辙啊，假设你从美国邮东西到广州市番禺区，首先快递送到中国（不过这里没有一个类似根域名服务器的中转站而已），然后往下到广东省，接下来是广州市，再往下是番禺了。</p><p>上面的是本地域名服务器的迭代解析过程，其实也可以递归查询，这里就不说了，道理差不多。</p><h1 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h1><p>现在整个域名系统已经可以为我们提供域名解析服务了，当我们输入域名，计算机发送DNS请求，然后DNS服务器返回给我们解析的结果，一切看起来很完美。然而是不是可以更完美呢？</p><p>回顾一下平时浏览网站的情况，我们会发现两个比较有意思的结论：</p><ol><li>80%的时间我们都在看那些20%的网站，这就是大名鼎鼎的80/20 Rule；</li><li>我们会在一个网站的不同网页之间跳转，也就是不断地访问同一个域名，类似程序访问的局部性原理。<br>这两条结论很容易让我们联想到<code>缓存机制</code>。如果我们将已经访问过的那些域名的解析结果缓存在自己的计算机上，那么下次访问的时候可以直接读取结果，不用再次重复DNS查询过程，给自己和域名服务器都节省了麻烦。</li></ol><p>当然，这样做的一个前提是要缓存的解析结果不会频繁更改，也就是说我十分钟后解析一个域名的结果和现在解析的结果是一样的。对大多数域名来说，这都是一个不争的事实。但是难免有一些“善变”的域名，他们可能会频繁更改自己的解析结果。为了使缓存机制适应这两类情况，我们在域名资源记录里面添加一个<code>Time_to_live</code>字段，表明这条记录最多可以缓存多久。对于那些“稳如泰山”的域名，给一个比较大的值，而那些“朝三暮四”的域名，则可以给定一个小的值。</p><p>我们既然可以在本机利用缓存，那么可不可以在域名服务器上也利用缓存机制呢，答案当然是可以的。因为对于域名服务器来说，上面的两条有意思的结论仍然有效。所以，域名服务器可以将那些访问过的域名资源记录缓存，用户再次发起请求时，可以直接返回缓存结果，不用去迭代或者递归解析。</p><p>关于DNS理论部分，更多内容还可以参考这两个文本：</p><ul><li><a href="https://tools.ietf.org/html/rfc1034" target="_blank" rel="noopener">RFC 1034: Domain Names - Concepts and Facilities</a></li></ul><h1 id="并没有结束"><a href="#并没有结束" class="headerlink" title="并没有结束"></a>并没有结束</h1><p>上面一大堆理论，看上去有点不明所以是吧，没事，接下来会结合实践来更加清晰地认识DNS这一最基础的系统。</p><p>其实不止是DNS，还有HTTPS、TCP、UDP这些很基础的协议，都值得我们静下心去好好认识它们。因为，写DNS之前，我以为我已经完全搞明白了它，但是写的过程发现好多地方自己根本就不知道，之前完全是停留在一个很浮夸的层面上。所以，是时候找时间好好把这些协议过一遍，用自己的语言，从<code>解决问题</code>的角度，记录下这些经典协议的故事了。</p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 协议森林 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重装windows系统</title>
      <link href="/2019/05/16/chong-zhuang-windows-xi-tong/"/>
      <url>/2019/05/16/chong-zhuang-windows-xi-tong/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>教程：<a href="http://www.wepe.com.cn/ubook/" target="_blank" rel="noopener">http://www.wepe.com.cn/ubook/</a><br>原版镜像下载：<a href="https://pan.baidu.com/s/1wbvP0GvjX0qMYCjssL2QvA" target="_blank" rel="noopener">https://pan.baidu.com/s/1wbvP0GvjX0qMYCjssL2QvA</a> 提取码: q22r</p>]]></content>
      
      
      <categories>
          
          <category> 黑科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python 电子书籍</title>
      <link href="/2019/05/16/python-dian-zi-shu-ji/"/>
      <url>/2019/05/16/python-dian-zi-shu-ji/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="一、入门"><a href="#一、入门" class="headerlink" title="一、入门"></a>一、入门</h3><ol><li><a href="https://book.douban.com/subject/26836700/" target="_blank" rel="noopener">Python编程快速上手—让繁琐工作自动化</a></li><li><a href="https://book.douban.com/subject/26829016/" target="_blank" rel="noopener">Python编程：从入门到实践</a></li></ol><h3 id="二、进阶"><a href="#二、进阶" class="headerlink" title="二、进阶"></a>二、进阶</h3><ol><li><a href="https://book.douban.com/subject/27028517/" target="_blank" rel="noopener">流畅的python</a></li><li><a href="https://book.douban.com/subject/26381341/" target="_blank" rel="noopener">Python Cookbook 中文版</a></li></ol><h3 id="三、爬虫"><a href="#三、爬虫" class="headerlink" title="三、爬虫"></a>三、爬虫</h3><ol><li><a href="https://book.douban.com/subject/30175598/" target="_blank" rel="noopener">Python 3网络爬虫开发实战</a></li></ol><h3 id="四、web"><a href="#四、web" class="headerlink" title="四、web"></a>四、web</h3><p>网站:</p><ol><li>django中文官方文档:   <a href="https://docs.djangoproject.com/zh-hans/2.2/" target="_blank" rel="noopener">https://docs.djangoproject.com/zh-hans/2.2/</a></li><li>django学习网站：<a href="https://code.ziqiangxuetang.com/django/django-tutorial.html" target="_blank" rel="noopener">https://code.ziqiangxuetang.com/django/django-tutorial.html</a></li><li>flask官方文档：<a href="http://flask.pocoo.org/" target="_blank" rel="noopener">http://flask.pocoo.org/</a></li></ol><p>书籍：</p><ol><li><a href="https://book.douban.com/subject/26274202/" target="_blank" rel="noopener">Flask Web开发：基于Python的Web应用开发实战</a></li><li><a href="https://book.douban.com/subject/30310340/" target="_blank" rel="noopener">Flask Web开发实战</a></li></ol><h3 id="五、数据分析"><a href="#五、数据分析" class="headerlink" title="五、数据分析"></a>五、数据分析</h3><p><a href="https://book.douban.com/subject/25779298/" target="_blank" rel="noopener">利用Python进行数据分析·第2版</a></p><p>(python3版本，目前没找到电子书，但是有翻译的博客) 博客地址：<a href="https://www.jianshu.com/p/04d180d90a3f" target="_blank" rel="noopener">https://www.jianshu.com/p/04d180d90a3f</a></p><h3 id="书籍下载地址"><a href="#书籍下载地址" class="headerlink" title="书籍下载地址"></a>书籍下载地址</h3><p>下载地址：<a href="https://pan.baidu.com/s/1DxcBF_fnFCb0TQf1Ub1Crg" target="_blank" rel="noopener">https://pan.baidu.com/s/1DxcBF_fnFCb0TQf1Ub1Crg</a> 提取码: 5fcy</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 书籍 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>02 选择排序</title>
      <link href="/2019/05/16/02-xuan-ze-pai-xu/"/>
      <url>/2019/05/16/02-xuan-ze-pai-xu/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="一、内存工作原理"><a href="#一、内存工作原理" class="headerlink" title="一、内存工作原理"></a>一、内存工作原理</h3><p>需要将数据存储到内存时，你请求计算机提供存储空间，计算机给你一个存储地址。</p><h3 id="二、运行时间"><a href="#二、运行时间" class="headerlink" title="二、运行时间"></a>二、运行时间</h3><table><thead><tr><th></th><th>数组</th><th>链表</th></tr></thead><tbody><tr><td>读取</td><td>O(1)</td><td>O(n)</td></tr><tr><td>插入</td><td>O(n)</td><td>O(1)</td></tr><tr><td>删除</td><td>O(n)</td><td>O(1)</td></tr></tbody></table><h3 id="三、实现代码"><a href="#三、实现代码" class="headerlink" title="三、实现代码"></a>三、实现代码</h3><pre><code>def find_smallest(arr):    smallest = 0    smallest_index = arr[0]    for i in range(1, len(arr)):        if smallest &gt; arr[i]:            smallest = arr[i]            smallest_index = i    return smallest_indexdef selection_sort(arr):    new_arr = []    for i in range(len(arr)):        smallest = find_smallest(arr)        new_arr.append(arr.pop(smallest))    return new_arrif __name__ == &#39;__main__&#39;:    arr = [5, 2, 4, 1, 7, 3]    print(selection_sort(arr))</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01 二分查找算法</title>
      <link href="/2019/05/15/01-er-fen-cha-zhao-suan-fa/"/>
      <url>/2019/05/15/01-er-fen-cha-zhao-suan-fa/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="一、使用场景"><a href="#一、使用场景" class="headerlink" title="一、使用场景"></a>一、使用场景</h3><p>仅当列表是有序的时候，二分查找才管用。</p><h3 id="二、代码实现"><a href="#二、代码实现" class="headerlink" title="二、代码实现"></a>二、代码实现</h3><pre><code>def binary_search(my_list, item):    low = 0    high = len(my_list) - 1    while low &lt;= high:        mid = (low + high) // 2        guess = my_list[mid]        if item == guess:            return mid        elif item &gt; guess:            low = mid + 1        else:            high = mid - 1    return Noneif __name__ == &#39;__main__&#39;:    my_list = [1, 3, 5, 6, 9]    print(binary_search(my_list, 9))    print(binary_search(my_list, -1))</code></pre><h3 id="三、算法的时间复杂度"><a href="#三、算法的时间复杂度" class="headerlink" title="三、算法的时间复杂度"></a>三、算法的时间复杂度</h3><p>二分算法的大 O 运行时间为 O(log N) 简单算法的大 O 运行时间为 O(N)</p><h3 id="四、小结"><a href="#四、小结" class="headerlink" title="四、小结"></a>四、小结</h3><ol><li>二分查找的速度比简单查找快得多。</li><li>O(log n)比O(n)快。需要搜索的元素越多，前者比后者就快得越多。</li><li>算法运行时间并不以秒为单位。</li><li>算法运行时间是从其增速的角度度量的。</li><li>算法运行时间用大O表示法表示。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>json 模块</title>
      <link href="/2019/04/02/json-mo-kuai/"/>
      <url>/2019/04/02/json-mo-kuai/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="用-loads-函数读取-JSON"><a href="#用-loads-函数读取-JSON" class="headerlink" title="用 loads()函数读取 JSON"></a>用 loads()函数读取 JSON</h2><pre><code>&gt;&gt;&gt; stringOfJsonData = &#39;{&quot;name&quot;: &quot;Zophie&quot;, &quot;isCat&quot;: true, &quot;miceCaught&quot;: 0,&quot;felineIQ&quot;: null}&#39;&gt;&gt;&gt; import json&gt;&gt;&gt; jsonDataAsPythonValue = json.loads(stringOfJsonData)&gt;&gt;&gt; jsonDataAsPythonValue{&#39;isCat&#39;: True, &#39;miceCaught&#39;: 0, &#39;name&#39;: &#39;Zophie&#39;, &#39;felineIQ&#39;: None}</code></pre><p>要将包含 JSON 数据的字符串转换为 Python 的值，就将它传递给 json.loads()函数（这个名字的意思是“load string”，而不 是“loads”）。</p><h2 id="用-dumps-函数写出-JSON"><a href="#用-dumps-函数写出-JSON" class="headerlink" title="用 dumps 函数写出 JSON"></a>用 dumps 函数写出 JSON</h2><pre><code>&gt;&gt;&gt; pythonValue = {&#39;isCat&#39;: True, &#39;miceCaught&#39;: 0, &#39;name&#39;: &#39;Zophie&#39;,&#39;felineIQ&#39;: None}&gt;&gt;&gt; import json&gt;&gt;&gt; stringOfJsonData = json.dumps(pythonValue)&gt;&gt;&gt; stringOfJsonData&#39;{&quot;isCat&quot;: true, &quot;felineIQ&quot;: null, &quot;miceCaught&quot;: 0, &quot;name&quot;: &quot;Zophie&quot; }&#39; </code></pre><p>json.dumps()函数（它表示“dump string”，而不是 “dumps”）将一个 Python 值转换成 JSON 格式的数据字符串。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSV 模块</title>
      <link href="/2019/04/02/csv-mo-kuai/"/>
      <url>/2019/04/02/csv-mo-kuai/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Reader-对象"><a href="#Reader-对象" class="headerlink" title="Reader 对象"></a>Reader 对象</h1><hr><pre><code>&gt;&gt;&gt; import csv&gt;&gt;&gt; exampleFile = open(&#39;example.csv&#39;)&gt;&gt;&gt; exampleReader = csv.reader(exampleFile)&gt;&gt;&gt; exampleData = list(exampleReader)&gt;&gt;&gt; exampleData[[&#39;4/5/2015 13:34&#39;, &#39;Apples&#39;, &#39;73&#39;], [&#39;4/5/2015 3:41&#39;, &#39;Cherries&#39;, &#39;85&#39;],[&#39;4/6/2015 12:46&#39;, &#39;Pears&#39;, &#39;14&#39;], [&#39;4/8/2015 8:59&#39;, &#39;Oranges&#39;, &#39;52&#39;],[&#39;4/10/2015 2:07&#39;, &#39;Apples&#39;, &#39;152&#39;], [&#39;4/10/2015 18:10&#39;, &#39;Bananas&#39;, &#39;23&#39;],[&#39;4/10/2015 2:40&#39;, &#39;Strawberries&#39;, &#39;98&#39;]]</code></pre><p>首先用 open()函数打开它，然后将它传递给 csv.reader()函数。这将返回一个 Reader 对象，供你使用。</p><h2 id="在-for-循环中，从-Reader-对象读取数据"><a href="#在-for-循环中，从-Reader-对象读取数据" class="headerlink" title="在 for 循环中，从 Reader 对象读取数据"></a>在 for 循环中，从 Reader 对象读取数据</h2><hr><pre><code>&gt;&gt;&gt; import csv&gt;&gt;&gt; exampleFile = open(&#39;example.csv&#39;)&gt;&gt;&gt; exampleReader = csv.reader(exampleFile)&gt;&gt;&gt; for row in exampleReader:        print(&#39;Row #&#39; + str(exampleReader.line_num) + &#39; &#39; + str(row))Row #1 [&#39;4/5/2015 13:34&#39;, &#39;Apples&#39;, &#39;73&#39;]Row #2 [&#39;4/5/2015 3:41&#39;, &#39;Cherries&#39;, &#39;85&#39;]Row #3 [&#39;4/6/2015 12:46&#39;, &#39;Pears&#39;, &#39;14&#39;]Row #4 [&#39;4/8/2015 8:59&#39;, &#39;Oranges&#39;, &#39;52&#39;]Row #5 [&#39;4/10/2015 2:07&#39;, &#39;Apples&#39;, &#39;152&#39;]Row #6 [&#39;4/10/2015 18:10&#39;, &#39;Bananas&#39;, &#39;23&#39;]Row #7 [&#39;4/10/2015 2:40&#39;, &#39;Strawberries&#39;, &#39;98&#39;]</code></pre><p>在导入 csv 模块，并从 CSV 文件得到 Reader 对象之后，可以循环遍历 Reader 对象中的行。每一行是一个值的列表，每个值表示一个单元格。print()函数将打印出当前行的编号以及该行的内容。要取得行号，就使用 Reader对象的 line_num 变量，它包含了当前行的编号 Reader 对象只能循环遍历一次。要再次读取 CSV 文件，必须调用 csv.reader，创建一个对象。</p><h1 id="Writer-对象"><a href="#Writer-对象" class="headerlink" title="Writer 对象"></a>Writer 对象</h1><hr><p>Writer 对象让你将数据写入 CSV 文件。要创建一个 Writer 对象，就使用 csv.writer()函数。</p><pre><code>&gt;&gt;&gt; import csv&gt;&gt;&gt; outputFile = open(&#39;output.csv&#39;, &#39;w&#39;, newline=&#39;&#39;)&gt;&gt;&gt; outputWriter = csv.writer(outputFile)&gt;&gt;&gt; outputWriter.writerow([&#39;spam&#39;, &#39;eggs&#39;, &#39;bacon&#39;, &#39;ham&#39;])21&gt;&gt;&gt; outputWriter.writerow([&#39;Hello, world!&#39;, &#39;eggs&#39;, &#39;bacon&#39;, &#39;ham&#39;])32&gt;&gt;&gt; outputWriter.writerow([1, 2, 3.141592, 4])16&gt;&gt;&gt; outputFile.close()</code></pre><p>请注意，Writer 对象自动转义了’Hello, world!’中的逗号，在 CSV 文件中使用了双引号。模块 csv 让你不必自己处理这些特殊情况。</p><h2 id="delimiter-和-lineterminator-关键字参数"><a href="#delimiter-和-lineterminator-关键字参数" class="headerlink" title="delimiter 和 lineterminator 关键字参数"></a>delimiter 和 lineterminator 关键字参数</h2><hr><pre><code>&gt;&gt;&gt; import csv&gt;&gt;&gt; csvFile = open(&#39;example.tsv&#39;, &#39;w&#39;, newline=&#39;&#39;)&gt;&gt;&gt; csvWriter = csv.writer(csvFile, delimiter=&#39;t&#39;, lineterminator=&#39;nn&#39;)&gt;&gt;&gt; csvWriter.writerow([&#39;apples&#39;, &#39;oranges&#39;, &#39;grapes&#39;])24&gt;&gt;&gt; csvWriter.writerow([&#39;eggs&#39;, &#39;bacon&#39;, &#39;ham&#39;])17&gt;&gt;&gt; csvWriter.writerow([&#39;spam&#39;, &#39;spam&#39;, &#39;spam&#39;, &#39;spam&#39;, &#39;spam&#39;, &#39;spam&#39;])32&gt;&gt;&gt; csvFile.close()</code></pre><p>默认情况下，CSV 文件的分隔符是逗号。行终止字符是出现在行末的字符。默认情况下，行终止字符是换行符。你可以利用 csv.writer()的 delimiter 和 lineterminator 关键字参数，将这些字符改成不同的值。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PyPDF2模块</title>
      <link href="/2019/04/02/pypdf2-mo-kuai/"/>
      <url>/2019/04/02/pypdf2-mo-kuai/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="PdfFileReader"><a href="#PdfFileReader" class="headerlink" title="PdfFileReader()"></a>PdfFileReader()</h2><pre><code>import PyPDF2pdfFileObj = open(&#39;meetingminutes.pdf&#39;, &#39;rb&#39;)pdfReader = PyPDF2.PdfFileReader(pdfFileObj)</code></pre><p>以读二进制模式打开 meetingminutes.pdf，并将它保存在 pdfFileObj 中。为了取得表示这个 PDF 的 PdfFileReader 对象，调用 PyPDF2. PdfFileReader()并向它传入 pdfFileObj。将这个 PdfFileReader 对象保存在 pdfReader 中。</p><h2 id="numPages-属性"><a href="#numPages-属性" class="headerlink" title="numPages 属性"></a>numPages 属性</h2><pre><code>&gt;&gt;&gt; pdfReader.numPages19</code></pre><p>该文档的总页数保存在 PdfFileReader 对象的 numPages 属性中。示例 PDF 文档有 19 页</p><h2 id="getPage"><a href="#getPage" class="headerlink" title="getPage()"></a>getPage()</h2><pre><code>&gt;&gt;&gt; pageObj = pdfReader.getPage(0)</code></pre><p>要从一页中提取文本，需要通过 PdfFileReader 对象取得一个 Page 对象，它表示 PDF 中的一页。可以调用 PdfFileReader 对象的 getPage()方法，向它传入感兴趣的页码（在我们的例子中是 0），从而取得 Page 对象。PyPDF2 在取得页面时使用从 0 开始的下标：第一页是 0 页，第二页是 1 页，以此类推。</p><h2 id="extractText"><a href="#extractText" class="headerlink" title="extractText()"></a>extractText()</h2><pre><code>&gt;&gt; pageObj.extractText()&#39;OOFFFFIICCIIAALL  BBOOAARRDD  MMIINNUUTTEESS   Meeting of nMarch 7n, 2014n        n     The Board of Elementary and Secondary Education shall provide leadership and ncreate policies for education that expand opportunities for children, empower nfamilies and communities, and advance Louisiana in an increasingly ncompetitive globnal market.n BOARD n of ELEMENTARYn and n SECONDARYn EDUCATIONn  &#39;</code></pre><p>在取得 Page 对象后，调用它的 extractText()方法，返回该页文本的字符串。</p><h2 id="isEncrypted-属性"><a href="#isEncrypted-属性" class="headerlink" title="isEncrypted 属性"></a>isEncrypted 属性</h2><pre><code>&gt;&gt;&gt; pdfReader.isEncryptedTrue</code></pre><p>所有 PdfFileReader 对象都有一个 isEncrypted 属性，如果 PDF 是加密的，它就是 True，如果不是，它就是 False。 在文件用正确的口令解密之前，尝试调用函数来读取文件，将会导致错误。</p><pre><code>&gt;&gt;&gt; pdfReader.getPage(0)Traceback (most recent call last): File &quot;&lt;pyshell#173&gt;&quot;, line 1, in &lt;module&gt; pdfReader.getPage()--snip--File &quot;C:Python34libsite-packagesPyPDF2pdf.py&quot;, line 1173, in getObject raise utils.PdfReadError(&quot;file has not been decrypted&quot;)PyPDF2.utils.PdfReadError: file has not been decrypted</code></pre><h2 id="decrypt"><a href="#decrypt" class="headerlink" title="decrypt()"></a>decrypt()</h2><pre><code>&gt;&gt;&gt; pdfReader.decrypt(&#39;rosebud&#39;)1&gt;&gt;&gt; pageObj = pdfReader.getPage(0)</code></pre><p>要读取加密的 PDF，就调用 decrypt()函数，传入口令字符串。在用正确的口令调用 decrypt()后，你会看到调用 getPage()不再导致错误。如果提供了错误的口令，decrypt()函数将返回 0，并且 getPage()会继续失败。请注意，decrypt()方法只解密了PdfFileReader 对象，而不是实际的 PDF 文件。在程序中止后，硬盘上的文件仍然是加密的。程序下次运行时，仍然需要再次调用 decrypt()。</p><h2 id="PdfFileWriter"><a href="#PdfFileWriter" class="headerlink" title="PdfFileWriter()"></a>PdfFileWriter()</h2><pre><code>&gt;&gt;&gt; pdfWriter = PyPDF2.PdfFileWriter()</code></pre><p>创建一个新的 PdfFileWriter对象，它表示一个空白的 PDF 文档。</p><h2 id="拷贝页面"><a href="#拷贝页面" class="headerlink" title="拷贝页面"></a>拷贝页面</h2><p>创建了一个新的 PDF 文件，将来自 meetingminutes.pdf 和 meetingminutes2.pdf 的页面组合在一个文档中。</p><pre><code>&gt;&gt;&gt; pdf1_file = open(&#39;meetingminutes.pdf&#39;, &#39;rb&#39;)&gt;&gt;&gt; pdf2_file = open(&#39;meetingminutes2.pdf&#39;, &#39;rb&#39;)&gt;&gt;&gt; pdf1_reader = PyPDF2.PdfFileReader(pdf1_file)&gt;&gt;&gt; pdf2_reader = PyPDF2.PdfFileReader(pdf2_file)&gt;&gt;&gt; pdf_writer = PyPDF2.PdfFileWriter()&gt;&gt;&gt; for pageNum in range(pdf1_reader.numPages):...     pageObj = pdf1_reader.getPage(pageNum)...     pdf_writer.addPage(pageObj)...     &gt;&gt;&gt; for pageNum in range(pdf2_reader.numPages):...     pageObj = pdf2_reader.getPage(pageNum)...     pdf_writer.addPage(pageObj)...     &gt;&gt;&gt; pdf_output_file = open(&#39;combinedminutes.pdf&#39;, &#39;wb&#39;)&gt;&gt;&gt; pdf_writer.write(pdf_output_file)&gt;&gt;&gt; pdf_output_file.close()&gt;&gt;&gt; pdf1_file.close()&gt;&gt;&gt; pdf2_file.close()</code></pre><h2 id="rotateClockwise"><a href="#rotateClockwise" class="headerlink" title="rotateClockwise()"></a>rotateClockwise()</h2><pre><code>&gt;&gt;&gt; import PyPDF2&gt;&gt;&gt; minutesFile = open(&#39;meetingminutes.pdf&#39;, &#39;rb&#39;)&gt;&gt;&gt; pdfReader = PyPDF2.PdfFileReader(minutesFile)&gt;&gt;&gt; page = pdfReader.getPage(0)&gt;&gt;&gt; page.rotateClockwise(90){&#39;/Contents&#39;: [IndirectObject(961, 0), IndirectObject(962, 0),--snip--}&gt;&gt;&gt; pdfWriter = PyPDF2.PdfFileWriter()&gt;&gt;&gt; pdfWriter.addPage(page)&gt;&gt;&gt; resultPdfFile = open(&#39;rotatedPage.pdf&#39;, &#39;wb&#39;)&gt;&gt;&gt; pdfWriter.write(resultPdfFile)&gt;&gt;&gt; resultPdfFile.close()&gt;&gt;&gt; minutesFile.close()</code></pre><p>利用 rotateClockwise()和 rotateCounterClockwise()方法，PDF 文档的页面也可以旋转 90 度的整数倍。向这些方法传入整数 90、180 或 270 就可以了。</p><h2 id="mergePage"><a href="#mergePage" class="headerlink" title="mergePage()"></a>mergePage()</h2><pre><code>&gt;&gt;&gt; import PyPDF2&gt;&gt;&gt; minutesFile = open(&#39;meetingminutes.pdf&#39;, &#39;rb&#39;)&gt;&gt;&gt; pdfReader = PyPDF2.PdfFileReader(minutesFile)&gt;&gt;&gt; minutesFirstPage = pdfReader.getPage(0)&gt;&gt;&gt; pdfWatermarkReader = PyPDF2.PdfFileReader(open(&#39;watermark.pdf&#39;, &#39;rb&#39;)) &gt;&gt;&gt; minutesFirstPage.mergePage(pdfWatermarkReader.getPage(0))&gt;&gt;&gt; pdfWriter = PyPDF2.PdfFileWriter()&gt;&gt;&gt; pdfWriter.addPage(minutesFirstPage)&gt;&gt;&gt; for pageNum in range(1, pdfReader.numPages):        pageObj = pdfReader.getPage(pageNum)        pdfWriter.addPage(pageObj)&gt;&gt;&gt; resultPdfFile = open(&#39;watermarkedCover.pdf&#39;, &#39;wb&#39;)&gt;&gt;&gt; pdfWriter.write(resultPdfFile)&gt;&gt;&gt; minutesFile.close()&gt;&gt;&gt; resultPdfFile.close()</code></pre><p>添加水印</p><h2 id="encrypt"><a href="#encrypt" class="headerlink" title="encrypt()"></a>encrypt()</h2><pre><code>&gt;&gt;&gt; import PyPDF2&gt;&gt;&gt; pdfFile = open(&#39;meetingminutes.pdf&#39;, &#39;rb&#39;)&gt;&gt;&gt; pdfReader = PyPDF2.PdfFileReader(pdfFile)&gt;&gt;&gt; pdfWriter = PyPDF2.PdfFileWriter()&gt;&gt;&gt; for pageNum in range(pdfReader.numPages):        pdfWriter.addPage(pdfReader.getPage(pageNum))&gt;&gt;&gt; pdfWriter.encrypt(&#39;swordfish&#39;)&gt;&gt;&gt; resultPdf = open(&#39;encryptedminutes.pdf&#39;, &#39;wb&#39;)&gt;&gt;&gt; pdfWriter.write(resultPdf)&gt;&gt;&gt; resultPdf.close()</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>clover 无广告绿色版</title>
      <link href="/2019/03/31/clover-wu-guang-gao-lu-se-ban/"/>
      <url>/2019/03/31/clover-wu-guang-gao-lu-se-ban/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://www.lanzous.com/i3m9era" target="_blank" rel="noopener">https://www.lanzous.com/i3m9era</a> 让文件管理器像浏览器一样，随意切换页面 下载后选择 <strong>绿化.bat 右键管理员运行，</strong>然后双击即可</p>]]></content>
      
      
      <categories>
          
          <category> 黑科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>openpyxl模块</title>
      <link href="/2019/03/27/openpyxl-mo-kuai/"/>
      <url>/2019/03/27/openpyxl-mo-kuai/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="openpyxl-load-workbook"><a href="#openpyxl-load-workbook" class="headerlink" title="openpyxl.load_workbook()"></a>openpyxl.load_workbook()</h3><hr><p>openpyxl.load_workbook()函数接受文件名，返回一个 workbook 数据类型的值。这个 workbook 对象代表这个 Excel 文件，有点类似 File 对象代表一个打开的文本文件。</p><pre><code>&gt;&gt;&gt; import openpyxl&gt;&gt;&gt; wb = openpyxl.load_workbook(&#39;example.xlsx&#39;)&gt;&gt;&gt; type(wb)&lt;class &#39;openpyxl.workbook.workbook.Workbook&#39;&gt;</code></pre><h3 id="openpyxl-get-sheet-names"><a href="#openpyxl-get-sheet-names" class="headerlink" title="openpyxl.get_sheet_names()"></a>openpyxl.get_sheet_names()</h3><hr><p>可以取得工作簿中所有表名的列表</p><pre><code>&gt;&gt;&gt; import openpyxl&gt;&gt;&gt; wb = openpyxl.load_workbook(&#39;example.xlsx&#39;)&gt;&gt;&gt; wb.get_sheet_names()[&#39;Sheet1&#39;, &#39;Sheet2&#39;, &#39;Sheet3&#39;]</code></pre><h3 id="openpyxl-get-sheet-by-name"><a href="#openpyxl-get-sheet-by-name" class="headerlink" title="openpyxl.get_sheet_by_name()"></a>openpyxl.get_sheet_by_name()</h3><hr><p>每个表由一个 Worksheet 对象表示，可以通过向工作簿方法 get_sheet_by_name()传递表名字符串获得。</p><pre><code>&gt;&gt;&gt; sheet = wb.get_sheet_by_name(&#39;Sheet3&#39;)&gt;&gt;&gt; sheet&lt;Worksheet &quot;Sheet3&quot;&gt;</code></pre><h3 id="openpyxl-get-active-sheet"><a href="#openpyxl-get-active-sheet" class="headerlink" title="openpyxl.get_active_sheet()"></a>openpyxl.get_active_sheet()</h3><hr><p>取得工作簿的活动表。活动表是工作簿在 Excel 中打开时出现的工作表。在取得 Worksheet对象后，可以通过 title 属性取得它的名称。</p><pre><code>&gt;&gt;&gt; sheet.title&#39;Sheet3&#39;&gt;&gt;&gt; anotherSheet = wb.get_active_sheet()&gt;&gt;&gt; anotherSheet&lt;Worksheet &quot;Sheet1&quot;&gt;</code></pre><h3 id="Cell-对象"><a href="#Cell-对象" class="headerlink" title="Cell 对象"></a>Cell 对象</h3><hr><pre><code>&gt;&gt;&gt; import openpyxl&gt;&gt;&gt; wb = openpyxl.load_workbook(&#39;example.xlsx&#39;)&gt;&gt;&gt; sheet = wb.get_sheet_by_name(&#39;Sheet1&#39;)&gt;&gt;&gt; sheet[&#39;A1&#39;]&lt;Cell Sheet1.A1&gt;&gt;&gt;&gt; sheet[&#39;A1&#39;].valuedatetime.datetime(2015, 4, 5, 13, 34, 2)&gt;&gt;&gt; print(sheet[&#39;A1&#39;].value)2015-04-05 13:34:02&gt;&gt;&gt; c = sheet[&#39;B1&#39;]&gt;&gt;&gt; c.value&#39;Apples&#39;&gt;&gt;&gt; &#39;Row &#39; + str(c.row) + &#39;, Column &#39; + c.column + &#39; is &#39; + c.valueTraceback (most recent call last):  File &quot;&lt;input&gt;&quot;, line 1, in &lt;module&gt;TypeError: must be str, not int&gt;&gt;&gt; &#39;Row &#39; + str(c.row) + &#39;, Column &#39; + str(c.column) + &#39; is &#39; + c.value&#39;Row 1, Column 2 is Apples&#39;&gt;&gt;&gt; &#39;Cell &#39; + c.coordinate + &#39; is &#39; + c.value&#39;Cell B1 is Apples&#39;&gt;&gt;&gt; sheet[&#39;C1&#39;].value73</code></pre><p>注意：中间有一个报错是因为书中的 c.column 是 ‘B’，改版之后变成了 2 Cell 对象有一个 value 属性，不出意外，它包含这个单元格中保存的值。Cell 对象也有 row、column 和 coordinate 属性，提供该单元格的位置信息。</p><h3 id="Worksheet-cell"><a href="#Worksheet-cell" class="headerlink" title="Worksheet.cell()"></a>Worksheet.cell()</h3><hr><p>调用表的 cell()方法时，可以传入整数作为 row 和 column 关键字参数，也可以得到一个单元格。第一行或第一列的整数是 1，不是 0。</p><pre><code>&gt;&gt;&gt; sheet.cell(row=1, column=2)&lt;Cell Sheet1.B1&gt;&gt;&gt;&gt; sheet.cell(row=1, column=2).value&#39;Apples&#39;&gt;&gt;&gt; for i in range(1, 8, 2): print(i, sheet.cell(row=i, column=2).value)1 Apples3 Pears5 Apples7 Strawberries</code></pre><h3 id="Worksheet-get-highest-row-和-Worksheet-get-highest-column"><a href="#Worksheet-get-highest-row-和-Worksheet-get-highest-column" class="headerlink" title="Worksheet.get_highest_row 和 Worksheet.get_highest_column"></a>Worksheet.get_highest_row 和 Worksheet.get_highest_column</h3><hr><p>get_highest_row 改成 max_row get_highest_column改成 max_column</p><pre><code>&gt;&gt;&gt; sheet.max_row7&gt;&gt;&gt; sheet.max_column3</code></pre><h3 id="column-index-from-string-和-get-column-letter"><a href="#column-index-from-string-和-get-column-letter" class="headerlink" title="column_index_from_string() 和 get_column_letter()"></a>column_index_from_string() 和 get_column_letter()</h3><hr><p>原来导入包的途径</p><p> from openpyxl.cell import get_column_letter, column_index_from_string</p><p>新版本</p><p>from openpyxl.utils import get_column_letter, column_index_from_string</p><p>使用</p><pre><code>&gt;&gt;&gt; get_column_letter(1)&#39;A&#39;&gt;&gt;&gt; get_column_letter(900)&#39;AHP&#39;&gt;&gt;&gt; wb = openpyxl.load_workbook(&#39;example.xlsx&#39;)&gt;&gt;&gt; sheet = wb.get_sheet_by_name(&#39;Sheet1&#39;)&gt;&gt;&gt; get_column_letter(sheet.max_column)&#39;C&#39;&gt;&gt;&gt; column_index_from_string(&#39;A&#39;)1&gt;&gt;&gt; column_index_from_string(&#39;AA&#39;)27</code></pre><h3 id="Worksheet-对象切片"><a href="#Worksheet-对象切片" class="headerlink" title="Worksheet 对象切片"></a>Worksheet 对象切片</h3><hr><p>取得电子表格中一行、一列或一个矩形区域中的所有Cell 对象。然后可以循环遍历这个切片中的所有单元格。</p><pre><code>&gt;&gt;&gt; import openpyxl&gt;&gt;&gt; wb = openpyxl.load_workbook(&#39;example.xlsx&#39;)&gt;&gt;&gt; sheet = wb.get_sheet_by_name(&#39;Sheet1&#39;)&gt;&gt;&gt; tuple(sheet[&#39;A1&#39;:&#39;C3&#39;])((&lt;Cell Sheet1.A1&gt;, &lt;Cell Sheet1.B1&gt;, &lt;Cell Sheet1.C1&gt;), (&lt;Cell Sheet1.A2&gt;,&lt;Cell Sheet1.B2&gt;, &lt;Cell Sheet1.C2&gt;), (&lt;Cell Sheet1.A3&gt;, &lt;Cell Sheet1.B3&gt;,&lt;Cell Sheet1.C3&gt;))&gt;&gt;&gt; sheet[&#39;A1&#39;:&#39;C3&#39;]((&lt;Cell &#39;Sheet1&#39;.A1&gt;, &lt;Cell &#39;Sheet1&#39;.B1&gt;, &lt;Cell &#39;Sheet1&#39;.C1&gt;), (&lt;Cell &#39;Sheet1&#39;.A2&gt;, &lt;Cell &#39;Sheet1&#39;.B2&gt;, &lt;Cell &#39;Sheet1&#39;.C2&gt;), (&lt;Cell &#39;Sheet1&#39;.A3&gt;, &lt;Cell &#39;Sheet1&#39;.B3&gt;, &lt;Cell &#39;Sheet1&#39;.C3&gt;))&gt;&gt;&gt; for rowOfCellObjects in sheet[&#39;A1&#39;:&#39;C3&#39;]:        for cellObj in rowOfCellObjects:            print(cellObj.coordinate, cellObj.value)        print(&#39;--- END OF ROW ---&#39;)A1 2015-04-05 13:34:02B1 ApplesC1 73--- END OF ROW ---A2 2015-04-05 03:41:23B2 CherriesC2 85--- END OF ROW ---A3 2015-04-06 12:46:51B3 PearsC3 14--- END OF ROW ---</code></pre><p>这个元组包含 3 个元组：每个元组代表 1 行，从指定区域的顶部到底部。这 3个内部元组中的每一个包含指定区域中一行的 Cell 对象，从最左边的单元格到最右边。所以总的来说，工作表的这个切片包含了从 A1 到 C3 区域的所有 Cell 对象，从左上角的单元格开始，到右下角的单元格结束。</p><h3 id="Worksheet-columns-和-Worksheet-rows"><a href="#Worksheet-columns-和-Worksheet-rows" class="headerlink" title="Worksheet.columns 和 Worksheet.rows"></a>Worksheet.columns 和 Worksheet.rows</h3><hr><p>原来获取特定列的方法，特定行的方法是</p><pre><code>sheet.columns[1]sheet.rows[1]</code></pre><p>现在 <code>sheet.columns</code> 和 <code>sheet.rows</code> 是 <code>generator</code> ，再像原来那样取值会报错，解决：</p><pre><code>list(sheet.columns)[1]list(sheet.rows)[1]</code></pre><p>循环取值</p><pre><code>for cellObj in list(sheet.columns)[1]:    print(cellObj.value)ApplesCherriesPearsOrangesApplesBananasStrawberries</code></pre><h3 id="openpyxl-Workbook"><a href="#openpyxl-Workbook" class="headerlink" title="openpyxl.Workbook()"></a>openpyxl.Workbook()</h3><hr><p>调用 openpyxl.Workbook()函数，创建一个新的空 Workbook 对象。</p><pre><code>&gt;&gt;&gt; import openpyxl&gt;&gt;&gt; wb = openpyxl.Workbook()&gt;&gt;&gt; wb.get_sheet_names()[&#39;Sheet&#39;]&gt;&gt;&gt; sheet = wb.get_active_sheet()&gt;&gt;&gt; sheet.title&#39;Sheet&#39;&gt;&gt;&gt; sheet.title = &#39;Spam Bacon Eggs Sheet&#39;&gt;&gt;&gt; wb.get_sheet_names()[&#39;Spam Bacon Eggs Sheet&#39;]</code></pre><h3 id="Workbook-save"><a href="#Workbook-save" class="headerlink" title="Workbook.save()"></a>Workbook.save()</h3><hr><p>当修改Workbook 对象或它的工作表和单元格时，电子表格文件不会保存，除非你调用 save()工作簿方法。</p><pre><code>&gt;&gt;&gt; import openpyxl&gt;&gt;&gt; wb = openpyxl.load_workbook(&#39;example.xlsx&#39;)&gt;&gt;&gt; sheet = wb.get_active_sheet()&gt;&gt;&gt; sheet.title = &#39;Spam Spam Spam&#39;&gt;&gt;&gt; wb.save(&#39;example_copy.xlsx&#39;)</code></pre><p>这里，我们改变了工作表的名称。为了保存变更，我们将文件名作为字符串传递给 save()方法。传入的文件名与最初的文件名不同，例如’example_copy.xlsx’，这将变更保存到电子表格的一份拷贝中。 当你编辑从文件中加载的一个电子表格时，总是应该将新的、编辑过的电子表格保存到不同的文件名中。这样，如果代码中有缺陷，导致新的保存到文件中数据不对或讹误，还有最初的电子表格文件可以处理。 补充： 有时候调用 save 函数时报错如下：</p><pre><code>&gt;&gt;&gt; wb.save(&#39;styled.xlsx&#39;)Traceback (most recent call last):  File &quot;&lt;input&gt;&quot;, line 1, in &lt;module&gt;  File &quot;G:python36libsite-packagesopenpyxlworkbookworkbook.py&quot;, line 396, in save    save_workbook(self, filename)  File &quot;G:python36libsite-packagesopenpyxlwriterexcel.py&quot;, line 292, in save_workbook    archive = ZipFile(filename, &#39;w&#39;, ZIP_DEFLATED, allowZip64=True)  File &quot;G:python36libzipfile.py&quot;, line 1090, in __init__    self.fp = io.open(file, filemode)PermissionError: [Errno 13] Permission denied: &#39;styled.xlsx&#39;</code></pre><p>解决：关闭打开的 excel 文档</p><h3 id="Workbook-create-sheet"><a href="#Workbook-create-sheet" class="headerlink" title="Workbook.create_sheet()"></a>Workbook.create_sheet()</h3><hr><pre><code>&gt;&gt;&gt; import openpyxl&gt;&gt;&gt; wb = openpyxl.Workbook()&gt;&gt;&gt; wb.get_sheet_names()[&#39;Sheet&#39;]&gt;&gt;&gt; wb.create_sheet()&lt;Worksheet &quot;Sheet1&quot;&gt;&gt;&gt;&gt; wb.get_sheet_names()[&#39;Sheet&#39;, &#39;Sheet1&#39;]&gt;&gt;&gt; wb.create_sheet(index=0, title=&#39;First Sheet&#39;)&lt;Worksheet &quot;First Sheet&quot;&gt;&gt;&gt;&gt; wb.get_sheet_names()[&#39;First Sheet&#39;, &#39;Sheet&#39;, &#39;Sheet1&#39;]&gt;&gt;&gt; wb.create_sheet(index=2, title=&#39;Middle Sheet&#39;)&lt;Worksheet &quot;Middle Sheet&quot;&gt;&gt;&gt;&gt; wb.get_sheet_names()[&#39;First Sheet&#39;, &#39;Sheet&#39;, &#39;Middle Sheet&#39;, &#39;Sheet1&#39;]</code></pre><p>create_sheet()方法返回一个新的 Worksheet 对象，名为 SheetX，它默认是工作簿的最后一个工作表。或者，可以利用 index 和 title 关键字参数，指定新工作表的索引或名称。 补充：Worksheet.get_active_sheet() 函数，会根据Worksheet.get_sheet_names() 函数的下标为 0 的值获取 Worksheet 对象</p><pre><code>&gt;&gt;&gt; wb.create_sheet(index=0, title=&#39;First Sheet&#39;)&lt;Worksheet &quot;First Sheet&quot;&gt;&gt;&gt;&gt; wb.get_sheet_names()[&#39;First Sheet&#39;, &#39;Sheet&#39;, &#39;Sheet1&#39;]&gt;&gt;&gt; wb.get_active_sheet()&lt;Worksheet &quot;First Sheet&quot;&gt;&gt;&gt;&gt; wb.create_sheet(index=0, title=&#39;new First Sheet&#39;)&lt;Worksheet &quot;new First Sheet&quot;&gt;&gt;&gt;&gt; wb.get_sheet_names()[&#39;new First Sheet&#39;, &#39;First Sheet&#39;, &#39;Sheet&#39;, &#39;Sheet1&#39;]&gt;&gt;&gt; wb.get_active_sheet()&lt;Worksheet &quot;new First Sheet&quot;&gt;</code></pre><h3 id="Workbook-remove-sheet"><a href="#Workbook-remove-sheet" class="headerlink" title="Workbook.remove_sheet()"></a>Workbook.remove_sheet()</h3><hr><pre><code>&gt;&gt;&gt; wb.get_sheet_names()[&#39;new First Sheet&#39;, &#39;First Sheet&#39;, &#39;Sheet&#39;, &#39;Sheet1&#39;]&gt;&gt;&gt; wb.remove(wb.get_sheet_by_name(&#39;new First Sheet&#39;))&gt;&gt;&gt; wb.remove(wb.get_sheet_by_name(&#39;Sheet1&#39;))&gt;&gt;&gt; wb.get_sheet_names()[&#39;First Sheet&#39;, &#39;Sheet&#39;]</code></pre><p>remove_sheet() 方法接受一个 Worksheet 对象作为其参数，而不是工作表名称的字符串。如果你只知道要删除的工作表的名称，就调用 get_sheet_by_name() ，将它的返回值传入  remove_sheet()。 在工作簿中添加或删除工作表之后，记得调用 save()方法来保存变更。</p><h2 id="将值写入单元格"><a href="#将值写入单元格" class="headerlink" title="将值写入单元格"></a>将值写入单元格</h2><pre><code>&gt;&gt;&gt; import openpyxl&gt;&gt;&gt; wb = openpyxl.Workbook()&gt;&gt;&gt; sheet = wb.get_sheet_by_name(&#39;Sheet&#39;)&gt;&gt;&gt; sheet[&#39;A1&#39;] = &#39;Hello world!&#39;&gt;&gt;&gt; sheet[&#39;A1&#39;].value&#39;Hello world!&#39;</code></pre><h2 id="Font-对象"><a href="#Font-对象" class="headerlink" title="Font 对象"></a>Font 对象</h2><p>书中代码如下：</p><pre><code>&gt;&gt;&gt; import openpyxl&gt;&gt;&gt; from openpyxl.styles import Font, Style&gt;&gt;&gt; wb = openpyxl.Workbook()&gt;&gt;&gt; sheet = wb.get_sheet_by_name(&#39;Sheet&#39;)&gt;&gt;&gt; italic24Font = Font(size=24, italic=True)&gt;&gt;&gt; styleObj = Style(font=italic24Font)&gt;&gt;&gt; sheet[&#39;A&#39;].style/styleObj&gt;&gt;&gt; sheet[&#39;A1&#39;] = &#39;Hello world!&#39;&gt;&gt;&gt; wb.save(&#39;styled.xlsx&#39;)</code></pre><p>会报错：</p><p><code>ImportError: cannot import name &#39;Style&#39;</code></p><p>解决：</p><pre><code>&gt;&gt;&gt; from openpyxl.styles import Font&gt;&gt;&gt; wb = openpyxl.Workbook()&gt;&gt;&gt; sheet = wb.get_sheet_by_name(&#39;Sheet&#39;)&gt;&gt;&gt; sheet[&#39;A1&#39;] = &#39;Hello world!&#39;&gt;&gt;&gt; italic24Font = Font(name=&#39;Calibri&#39;,size=24, italic=True)&gt;&gt;&gt; sheet[&#39;A1&#39;].font = italic24Font&gt;&gt;&gt; wb.save(&#39;styled.xlsx&#39;)</code></pre><p>Font 函数中的 name 参数是选择字体，size 字体大小，italic 是否为斜体，最后将 Font 对象赋值给 Cell 对象的 font 属性即可 创建了各种字体风格：</p><pre><code>&gt;&gt;&gt; wb = openpyxl.Workbook()&gt;&gt;&gt; sheet = wb.get_sheet_by_name(&#39;Sheet&#39;)&gt;&gt;&gt; fontObj1 = Font(name=&#39;Times New Roman&#39;, bold=True)&gt;&gt;&gt; sheet[&#39;A1&#39;].font = fontObj1&gt;&gt;&gt; fontObj2 = Font(name=&#39;Calibri&#39;,size=24, italic=True)&gt;&gt;&gt; sheet[&#39;B3&#39;].font = fontObj2&gt;&gt;&gt; sheet[&#39;A1&#39;] = &#39;Bold Times New Roman&#39;&gt;&gt;&gt; sheet[&#39;B3&#39;] = &#39;24 pt Italic&#39;&gt;&gt;&gt; wb.save(&#39;styles.xlsx&#39;)</code></pre><h3 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h3><p>–</p><pre><code>&gt;&gt;&gt; import openpyxl&gt;&gt;&gt; wb = openpyxl.Workbook()&gt;&gt;&gt; sheet = wb.get_active_sheet()&gt;&gt;&gt; sheet[&#39;A1&#39;] = 200&gt;&gt;&gt; sheet[&#39;A2&#39;] = 300&gt;&gt;&gt; sheet[&#39;A3&#39;] = &#39;=SUM(A1:A2)&#39;&gt;&gt;&gt; wb.save(&#39;writeFormula.xlsx&#39;)</code></pre><p>单元格 A1 和 A2 分别设置为 200 和 300。单元格 A3 设置为一个公式，求出 A1和 A2 的和。如果在 Excel 中打开这个电子表格，A3 的值将显示为 500。 load_workbook()的 data_only 关键字参数设置为 True。这意味着 Workbook 对象要么显示公式，要么显示公式的结果，不能兼得。</p><pre><code>&gt;&gt;&gt; import openpyxl&gt;&gt;&gt; wbFormulas = openpyxl.load_workbook(&#39;writeFormula.xlsx&#39;)&gt;&gt;&gt; sheet = wbFormulas.get_active_sheet()&gt;&gt;&gt; sheet[&#39;A3&#39;].value&#39;=SUM(A1:A2)&#39;&gt;&gt;&gt; wbDataOnly = openpyxl.load_workbook(&#39;writeFormula.xlsx&#39;, data_only=True)&gt;&gt;&gt; sheet = wbDataOnly.get_active_sheet()&gt;&gt;&gt; sheet[&#39;A3&#39;].value500</code></pre><h3 id="row-dimensions-和-column-dimensions"><a href="#row-dimensions-和-column-dimensions" class="headerlink" title="row_dimensions 和 column_dimensions"></a>row_dimensions 和 column_dimensions</h3><pre><code>&gt;&gt;&gt; wb = openpyxl.Workbook()&gt;&gt;&gt; sheet = wb.get_active_sheet()&gt;&gt;&gt; sheet = wb.get_active_sheet()&gt;&gt;&gt; sheet[&#39;A1&#39;] = &#39;Tall row&#39;&gt;&gt;&gt; sheet[&#39;B2&#39;] = &#39;Wide column&#39;&gt;&gt;&gt; sheet.row_dimensions[1].height = 70&gt;&gt;&gt; sheet.column_dimensions[&#39;B&#39;].width = 20&gt;&gt;&gt; wb.save(&#39;dimensions.xlsx&#39;) </code></pre><h3 id="Worksheet-merge-cells"><a href="#Worksheet-merge-cells" class="headerlink" title="Worksheet.merge_cells()"></a>Worksheet.merge_cells()</h3><hr><pre><code>&gt;&gt;&gt; wb = openpyxl.Workbook()&gt;&gt;&gt; sheet = wb.get_active_sheet()&gt;&gt;&gt; sheet.merge_cells(&#39;A1:D3&#39;)&gt;&gt;&gt; sheet[&#39;A1&#39;] = &#39;Twelve cells merged together.&#39;&gt;&gt;&gt; sheet.merge_cells(&#39;C5:D5&#39;)&gt;&gt;&gt; sheet[&#39;C5&#39;] = &#39;Two merged cells.&#39;&gt;&gt;&gt; wb.save(&#39;merged.xlsx&#39;)</code></pre><p><strong>合并后只可以往左上角写入数据，也就是区间中</strong><code>:</code><strong>左边的坐标。</strong>如果这些要合并的单元格都有数据，只会保留左上角的数据，其他则丢弃。换句话说<strong>若合并前不是在左上角写入数据，合并后单元格中不会有数据。</strong></p><h3 id="Worksheet-unmerge-cells"><a href="#Worksheet-unmerge-cells" class="headerlink" title="Worksheet.unmerge_cells()"></a>Worksheet.unmerge_cells()</h3><hr><pre><code>&gt;&gt;&gt; import openpyxl&gt;&gt;&gt; wb = openpyxl.load_workbook(&#39;merged.xlsx&#39;)&gt;&gt;&gt; sheet = wb.get_active_sheet()&gt;&gt;&gt; sheet.unmerge_cells(&#39;A1:D3&#39;)&gt;&gt;&gt; sheet.unmerge_cells(&#39;C5:D5&#39;)&gt;&gt;&gt; wb.save(&#39;merged.xlsx&#39;)</code></pre><p>拆分后，值回到A1位置。</p><h3 id="Worksheet-freeze-panes"><a href="#Worksheet-freeze-panes" class="headerlink" title="Worksheet.freeze_panes"></a>Worksheet.freeze_panes</h3><hr><pre><code>&gt;&gt;&gt; import openpyxl&gt;&gt;&gt; wb = openpyxl.load_workbook(&#39;produceSales.xlsx&#39;)&gt;&gt;&gt; sheet = wb.get_active_sheet()&gt;&gt;&gt; sheet.freeze_panes = &#39;A2&#39;&gt;&gt;&gt; wb.save(&#39;freezeExample.xlsx&#39;)</code></pre><p>如果将 freeze_panes 属性设置为’A2’，行 1 将永远可见，无论用户将电子表格滚动到何处</p><h3 id="图表"><a href="#图表" class="headerlink" title="图表"></a>图表</h3><p>–</p><p>书中的代码报错误，于是使用官方文档中的代码</p><pre><code>&gt;&gt;&gt; from openpyxl.chart import BarChart&gt;&gt;&gt; chartObj = BarChart()&gt;&gt;&gt; chartObj.title = &#39;First series&#39;&gt;&gt;&gt; from openpyxl.chart import Reference&gt;&gt;&gt; data = Reference(ws, min_col=1, min_row=1, max_row=10, max_col=1)&gt;&gt;&gt; chartObj.add_data(data)&gt;&gt;&gt; ws.add_chart(chartObj, &#39;C2&#39;)&gt;&gt;&gt; wb.save(&#39;sampleChart.xlsx&#39;)</code></pre><p>Reference 对象选择数据区域，BarChart 对象为柱形图表对象，设置完后，利用 worksheet.add_chart 函数 添加 BarChart 对象</p><h3 id="图表布局"><a href="#图表布局" class="headerlink" title="图表布局"></a>图表布局</h3><hr><pre><code>&gt;&gt;&gt; from copy import deepcopy&gt;&gt;&gt; from openpyxl.chart.layout import Layout, ManualLayout&gt;&gt;&gt; ch2 = deepcopy(chartObj)... ch2.title = &quot;Manual chart layout&quot;... ch2.legend.position = &quot;tr&quot;... ch2.layout=Layout(...     manualLayout=ManualLayout(...         x=0.25, y=0.25...     )... )&gt;&gt;&gt; ws.add_chart(ch2, &#39;N2&#39;)&gt;&gt;&gt; wb.save(&#39;sampleChart.xlsx&#39;)</code></pre><p>x , y 控制图表在容器中的位置，x是从左边开始的水平位置y是顶边开始垂直的位置 <code>legend.position = &#39;tr&#39;</code> 是图例布局</p><pre><code>&gt;&gt;&gt; ch6 = deepcopy(chartObj)... ch6.title = &quot;Manual chart layout&quot;... ch6.layout=Layout(...     manualLayout=ManualLayout(...         h=1, w=1...     )... )... ws.add_chart(ch6, &#39;N36&#39;)... wb.save(&#39;sampleChart.xlsx&#39;)</code></pre><p>h, w 是调整大小</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>windows10开启卓越性能</title>
      <link href="/2019/03/26/windows10-kai-qi-zhuo-yue-xing-neng/"/>
      <url>/2019/03/26/windows10-kai-qi-zhuo-yue-xing-neng/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="软件下载地址"><a href="#软件下载地址" class="headerlink" title="软件下载地址"></a>软件下载地址</h2><p><strong>UltimatePlan.pow</strong> 下载地址： 链接: <a href="https://pan.baidu.com/s/1Hb16-iqTCT71jDAr-v5RNA" target="_blank" rel="noopener">https://pan.baidu.com/s/1Hb16-iqTCT71jDAr-v5RNA</a> 提取码: w8g8 </p><h2 id="开启条件"><a href="#开启条件" class="headerlink" title="开启条件"></a>开启条件</h2><p>不能是家庭版，并且版本要在 17666 以后才可以</p><h2 id="怎么查看自己的系统版本"><a href="#怎么查看自己的系统版本" class="headerlink" title="怎么查看自己的系统版本"></a>怎么查看自己的系统版本</h2><p>键盘快捷键 <strong>win+R 打开运行窗口，输入 dxdiag 后运行</strong>。此时会弹出一个 DirectX 诊断工具，在这个窗口中的系统信息里就可以看到自己系统的具体版本了。 <img src="1.png" alt="系统版本"></p><h2 id="17666以后版本打开卓越性能"><a href="#17666以后版本打开卓越性能" class="headerlink" title="17666以后版本打开卓越性能"></a>17666以后版本打开卓越性能</h2><p>首先在系统左下角的搜索框中搜索“ <em><em>powershell </em></em>”，便会出现一个叫做“ Windows Powershell ”的选项，右键选择以管理员身份运行。 运行并弹出窗口之后，直接在这个窗口中运行这条指令：</p><p>powercfg -duplicatescheme e9a42b02-d5df-448d-aa00-03f14749eb61</p><p>成功后会给出这样的提示： <img src="2.png" alt="成功后的提示"> 但是这样仅仅只是显示出了卓越性能的选项，还并没有选择卓越模式，接下来只剩下这最后一步了。 打开系统的搜索框，搜索“<strong>选择电源计划</strong>”后打开（也可以在控制面板&gt;电源计划或者系统设置中打开），然后就会出现“卓越模式”这个选项，选择之后你的电脑就会以卓越模式运行了。 <img src="3.png" alt></p><h2 id="17666以前版本打开卓越性能"><a href="#17666以前版本打开卓越性能" class="headerlink" title="17666以前版本打开卓越性能"></a>17666以前版本打开卓越性能</h2><p>17666以前的版本需要<strong>先下载一个叫做 UltimatePlan.pow 的小文件</strong>。下载好这个文件后随意放在硬盘中的一个位置，最好是根目录，比如放在D盘根目录中。 放好这个文件后，在系统左下角的搜索框中搜索“<strong>powershell</strong>”，便会出现一个叫做“Windows Powershell”的选项，右键选择以管理员身份运行。 运行并弹出窗口之后，直接在这个窗口中运行这条指令：</p><p>powercfg –import D:\\UltimatePlan.pow</p><p>注意这条指令的最后，是刚才那个文件的地址，也就是说你的文件放在那里，powercfg –import的后面就需要改为你文件的绝对地址，<strong>如果你懒得更改指令的话，就直接把那个文件放在D盘根目录就好了</strong>。 运行指令成功后会给出这样的提示： <img src="4.png" alt> 在之后的步骤就与上面的相同了，按照上面的步骤操作即可。不过测试的时候发现17666以前的版本的卓越性能选项有可能出现乱码，但并不影响使用，只需要选择这个多出来的选项就可以了。 <img src="5.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 黑科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>百度网盘加速下载</title>
      <link href="/2019/03/26/bai-du-wang-pan-jia-su-xia-zai/"/>
      <url>/2019/03/26/bai-du-wang-pan-jia-su-xia-zai/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这里推荐speedpan，免登陆下载，或者可以自己分享出来，到软件中下载也行 <a href="https://www.speedpan.com/" target="_blank" rel="noopener">https://www.speedpan.com/</a> 如果账号被限制了，可以选择Speedpan 极速版 用法跟原来的一样，分享出来下载即可，速度更快，但是要收费  1 元 10 G 3 元 50 G</p>]]></content>
      
      
      <categories>
          
          <category> 黑科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读写文件</title>
      <link href="/2019/03/16/os-mo-kuai/"/>
      <url>/2019/03/16/os-mo-kuai/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="文件与文件路径"><a href="#文件与文件路径" class="headerlink" title="文件与文件路径"></a>文件与文件路径</h1><h2 id="Windows-上的倒斜杠以及-OS-X-和-Linux-上的正斜杠"><a href="#Windows-上的倒斜杠以及-OS-X-和-Linux-上的正斜杠" class="headerlink" title="Windows 上的倒斜杠以及 OS X 和 Linux 上的正斜杠"></a>Windows 上的倒斜杠以及 OS X 和 Linux 上的正斜杠</h2><p>在 Windows 上，路径书写使用倒斜杠作为文件夹之间的分隔符。但在 OS X 和Linux 上，使用正斜杠作为它们的路径分隔符。如果想要程序运行在所有操作系统上，在编写 Python 脚本时，就必须处理这两种情况。 os.path.join()会返回一个文件路径的字符串，包含正确的路径分隔符。在交互式环境中输入以下代码：</p><pre><code>&gt;&gt;&gt; import os&gt;&gt;&gt; os.path.join(&#39;usr&#39;, &#39;bin&#39;, &#39;spam&#39;)&#39;usrbinspam&#39;</code></pre><p>我在 Windows 上运行这些交互式环境的例子，所以，os.path.join(‘usr’, ‘bin’,’spam’)返回’usrbinspam’（请注意，倒斜杠有两个，因为每个倒斜杠需要由另一个倒斜杠字符来转义）。如果我在 OS X 或 Linux 上调用这个函数，该字符串就会是’usr/bin/spam’。 下面的例子将一个文件名列表中的名称，添加到文件夹名称的末尾。</p><pre><code>&gt;&gt;&gt; myFiles = [&#39;accounts.txt&#39;, &#39;details.csv&#39;, &#39;invite.docx&#39;]&gt;&gt;&gt; for filename in myFiles: print(os.path.join(&#39;C:Usersasweigart&#39;, filename))C:Usersasweigartaccounts.txtC:Usersasweigartdetails.csvC:Usersasweigartinvite.docx</code></pre><h2 id="当前工作目录"><a href="#当前工作目录" class="headerlink" title="当前工作目录"></a>当前工作目录</h2><p>利用 os.getcwd()函数，可以取得当前工作路径的字符串，并可以利用 os.chdir()改变它。在交互式环境中输入以下代码：</p><pre><code>&gt;&gt;&gt; import os&gt;&gt;&gt; os.getcwd()&#39;C:Python34&#39;&gt;&gt;&gt; os.chdir(&#39;C:WindowsSystem32&#39;)&gt;&gt;&gt; os.getcwd()&#39;C:WindowsSystem32&#39;</code></pre><p>这里，当前工作目录设置为 C:Python34，所以文件名 project.docx 指向C:Python34project.docx。如果我们将当前工作目录改为 C:Windows，文件就被解释为 C:Windowsproject.docx。如果要更改的当前工作目录不存在，Python 就会显示一个错误。</p><pre><code>&gt;&gt;&gt; os.chdir(&#39;C:ThisFolderDoesNotExist&#39;)Traceback (most recent call last): File &quot;&lt;pyshell#18&gt;&quot;, line 1, in &lt;module&gt; os.chdir(&#39;C:ThisFolderDoesNotExist&#39;)FileNotFoundError: [WinError 2] The system cannot find the file specified:&#39;C:ThisFolderDoesNotExist&#39;</code></pre><p>注意： 虽然文件夹是目录的更新的名称，但请注意，当前工作目录（或当前目录）是标准术语，没有当前工作文件夹这种说法。</p><h2 id="用-os-makedirs-创建新文件夹"><a href="#用-os-makedirs-创建新文件夹" class="headerlink" title="用 os.makedirs()创建新文件夹"></a>用 os.makedirs()创建新文件夹</h2><p>程序可以用 os.makedirs()函数创建新文件夹（目录）。在交互式环境中输入以下代码：</p><pre><code>&gt;&gt;&gt; import os&gt;&gt;&gt; os.makedirs(&#39;C:deliciouswalnutwaffles&#39;)</code></pre><p>这不仅将创建 C:delicious 文件夹，也会在 C:delicious 下创建 walnut 文件夹，并在 C:deliciouswalnut 中创建 waffles 文件夹。也就是说，os.makedirs()将创建所有必要的中间文件夹，目的是确保完整路径名存在。</p><h2 id="处理绝对路径和相对路径"><a href="#处理绝对路径和相对路径" class="headerlink" title="处理绝对路径和相对路径"></a>处理绝对路径和相对路径</h2><p>调用 os.path.abspath(path)将返回参数的绝对路径的字符串。这是将相对路径转换为绝对路径的简便方法。</p><ul><li>调用 os.path.isabs(path)，如果参数是一个绝对路径，就返回 True，如果参数是一个相对路径，就返回 False。</li><li>调用 os.path.relpath(path, start)将返回从 start 路径到 path 的相对路径的字符串。如果没有提供 start，就使用当前工作目录作为开始路径。在交互式环境中尝试以下函数：<pre><code>&gt;&gt;&gt; os.path.abspath(&#39;.&#39;)&#39;C:Python34&#39;&gt;&gt;&gt; os.path.abspath(&#39;.Scripts&#39;)&#39;C:Python34Scripts&#39;&gt;&gt;&gt; os.path.isabs(&#39;.&#39;)False&gt;&gt;&gt; os.path.isabs(os.path.abspath(&#39;.&#39;))True</code></pre>在交互式环境中，输入以下对 os.path.relpath()的调用：<pre><code>&gt;&gt;&gt; os.path.relpath(&#39;C:Windows&#39;, &#39;C:&#39;)&#39;Windows&#39;&gt;&gt;&gt; os.path.relpath(&#39;C:Windows&#39;, &#39;C:spameggs&#39;)&#39;....Windows&#39;&gt;&gt;&gt; os.getcwd()&#39;C:Python34&#39;</code></pre>调用 os.path.dirname(path)将返回一个字符串，它包含 path 参数中最后一个斜杠之前的所有内容。调用 os.path.basename(path)将返回一个字符串，它包含 path 参数中最后一个斜杠之后的所有内容。基本名称跟在路径中最后一个斜杠后，它和文件名一样，目录名称是最后一个斜杠之前的所有内容。<pre><code>&gt;&gt;&gt; path = &#39;C:WindowsSystem32calc.exe&#39;&gt;&gt;&gt; os.path.basename(path)&#39;calc.exe&#39;&gt;&gt;&gt; os.path.dirname(path)&#39;C:WindowsSystem32&#39;</code></pre>如果同时需要一个路径的目录名称和基本名称，就可以调用 os.path.split()，获得这两个字符串的元组，像这样：<pre><code>&gt;&gt;&gt; calcFilePath = &#39;C:WindowsSystem32calc.exe&#39;&gt;&gt;&gt; os.path.split(calcFilePath)(&#39;C:WindowsSystem32&#39;, &#39;calc.exe&#39;)</code></pre>但如果需要两个值，os.path.split()是很好的快捷方式。同时也请注意，os.path.split()不会接受一个文件路径并返回每个文件夹的字符串的列表。如果需要这样，请使用 split()字符串方法，并根据 os.path.sep 中的字符串进行分割。<pre><code>&gt;&gt;&gt; calcFilePath.split(os.path.sep)[&#39;C:&#39;, &#39;Windows&#39;, &#39;System32&#39;, &#39;calc.exe&#39;]</code></pre></li></ul><blockquote><blockquote><blockquote><p>‘/usr/bin’.split(os.path.sep)<br>[‘’, ‘usr’, ‘bin’]</p><pre><code></code></pre></blockquote></blockquote></blockquote><h2 id="查看文件大小和文件夹内容"><a href="#查看文件大小和文件夹内容" class="headerlink" title="查看文件大小和文件夹内容"></a>查看文件大小和文件夹内容</h2><ul><li>调用 os.path.getsize(path)将返回 path 参数中文件的字节数。</li><li>调用 os.listdir(path)将返回文件名字符串的列表，包含 path 参数中的每个文件（请注意，这个函数在 os 模块中，而不是 os.path）。</li></ul><p>补充： os.listdir(path) 函数显示的是path下的所有文件名，包括文件夹名字，但是文件夹下的文件名就不会显示出来了</p><pre><code>&gt;&gt;&gt; os.path.getsize(&#39;C:WindowsSystem32calc.exe&#39;)776192&gt;&gt;&gt; os.listdir(&#39;C:WindowsSystem32&#39;)[&#39;0409&#39;, &#39;12520437.cpx&#39;, &#39;12520850.cpx&#39;, &#39;5U877.ax&#39;, &#39;aaclient.dll&#39;,--snip--&#39;xwtpdui.dll&#39;, &#39;xwtpw32.dll&#39;, &#39;zh-CN&#39;, &#39;zh-HK&#39;, &#39;zh-TW&#39;, &#39;zipfldr.dll&#39;]</code></pre><p>可以看到，我的计算机上的 calc.exe 程序是 776192 字节。在我的 C:Windowssystem32 下有许多文件。如果想知道这个目录下所有文件的总字节数，就可以同时使用 os.path.getsize()和 os.listdir()。</p><pre><code>&gt;&gt;&gt; totalSize = 0&gt;&gt;&gt; for filename in os.listdir(&#39;C:WindowsSystem32&#39;): totalSize = totalSize + os.path.getsize(os.path.join(&#39;C:WindowsSystem32&#39;, filename))&gt;&gt;&gt; print(totalSize)1117846456</code></pre><p>当循环遍历 C:WindowsSystem32 文件夹中的每个文件时，totalSize 变量依次增加每个文件的字节数。请注意，我在调用 os.path.getsize()时，使用了 os.path.join()来连接文件夹名称和当前的文件名。os.path.getsize()返回的整数添加到 totalSize 中。在循环遍历所有文件后，我打印出 totalSize，看看 C:WindowsSystem32 文件夹的总字节数。</p><h2 id="检查路径有效性"><a href="#检查路径有效性" class="headerlink" title="检查路径有效性"></a>检查路径有效性</h2><p>如果你提供的路径不存在，许多 Python 函数就会崩溃并报错。os.path 模块提供了一些函数，用于检测给定的路径是否存在，以及它是文件还是文件夹。</p><ul><li>如果 path 参数所指的文件或文件夹存在，调用 os.path.exists(path)将返回 True，否则返回 False。</li><li>如果 path 参数存在，并且是一个文件，调用 os.path.isfile(path)将返回 True，否则返回 False。</li><li>如果 path 参数存在，并且是一个文件夹，调用 os.path.isdir(path)将返回 True，否则返回 False。<pre><code>&gt;&gt;&gt; os.path.exists(&#39;C:Windows&#39;)True&gt;&gt;&gt; os.path.exists(&#39;C:some_made_up_folder&#39;)False&gt;&gt;&gt; os.path.isdir(&#39;C:WindowsSystem32&#39;)True&gt;&gt;&gt; os.path.isfile(&#39;C:WindowsSystem32&#39;)False&gt;&gt;&gt; os.path.isdir(&#39;C:WindowsSystem32calc.exe&#39;)False&gt;&gt;&gt; os.path.isfile(&#39;C:WindowsSystem32calc.exe&#39;)True</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="/2019/03/15/re-mo-kuai/"/>
      <url>/2019/03/15/re-mo-kuai/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="创建正则表达式对象"><a href="#创建正则表达式对象" class="headerlink" title="创建正则表达式对象"></a>创建正则表达式对象</h2><pre><code>phoneNumRegex = re.compile(r&#39;ddd-ddd-dddd&#39;)</code></pre><p>传入一个字符串值，表示正则表达式，它将返回一个 Regex 模式对象（或者就简称为 Regex 对象）。</p><h2 id="匹配-Regex-对象"><a href="#匹配-Regex-对象" class="headerlink" title="匹配 Regex 对象"></a>匹配 Regex 对象</h2><p>如果字符串中没有找到该正则表达式模式，search()方法将返回 None。如果找到了该模式，search()方法将返回一个 Match 对象。Match 对象有一个 group()方法，它返回被查找字符串中实际匹配的文本</p><pre><code>phoneNumRegex = re.compile(r&#39;ddd-ddd-dddd&#39;)mo = phoneNumRegex.search(&#39;My number is 415-555-4242.&#39;)print(&#39;Phone number found: &#39; + mo.group())Phone number found: 415-555-4242</code></pre><h2 id="利用括号分组"><a href="#利用括号分组" class="headerlink" title="利用括号分组"></a>利用括号分组</h2><p>正则表达式字符串中的第一对括号是第 1 组。第二对括号是第 2 组。向 group()匹配对象方法传入整数 1 或 2，就可以取得匹配文本的不同部分。向 group()方法传入 0 或不传入参数，将返回整个匹配的文本。</p><pre><code>&gt;&gt;&gt; phoneNumRegex = re.compile(r&#39;(ddd)-(ddd-dddd)&#39;)&gt;&gt;&gt; mo = phoneNumRegex.search(&#39;My number is 415-555-4242.&#39;)&gt;&gt;&gt; mo.group(1)&#39;415&#39; </code></pre><p>如果想要一次就获取所有的分组，请使用 groups()方法，注意函数名的复数形式。</p><pre><code>&gt;&gt;&gt; mo.groups()(&#39;415&#39;, &#39;555-4242&#39;)&gt;&gt;&gt; areaCode, mainNumber = mo.groups()&gt;&gt;&gt; print(areaCode)415&gt;&gt;&gt; print(mainNumber)555-4242</code></pre><h2 id="管道匹配多个分组"><a href="#管道匹配多个分组" class="headerlink" title="管道匹配多个分组"></a>管道匹配多个分组</h2><p>字符|称为“管道”。希望匹配许多表达式中的一个时，就可以使用它。如果 Batman 和 Tina Fey 都出现在被查找的字符串中，第一次出现的匹配文本，将作为 Match 对象返回。</p><pre><code>&gt;&gt;&gt; heroRegex = re.compile (r&#39;Batman|Tina Fey&#39;)&gt;&gt;&gt; mo1 = heroRegex.search(&#39;Batman and Tina Fey.&#39;)&gt;&gt;&gt; mo1.group()&#39;Batman&#39;&gt;&gt;&gt; mo2 = heroRegex.search(&#39;Tina Fey and Batman.&#39;)&gt;&gt;&gt; mo2.group()&#39;Tina Fey&#39; </code></pre><p>也可以使用管道来匹配多个模式中的一个，作为正则表达式的一部分。例如，假设你希望匹配 ‘Batman’ 、’Batmobile’ 、’Batcopter’ 和 ‘Batbat’ 中任意一个。因为所有这些字符串都以 Bat 开始，所以如果能够只指定一次前缀，就很方便。这可以通过括号实现。在交互式环境中输入以下代码：</p><pre><code>&gt;&gt;&gt; batRegex = re.compile(r&#39;Bat(man|mobile|copter|bat)&#39;)&gt;&gt;&gt; mo = batRegex.search(&#39;Batmobile lost a wheel&#39;)&gt;&gt;&gt; mo.group()&#39;Batmobile&#39;&gt;&gt;&gt; mo.group(1)&#39;mobile</code></pre><h2 id="用问号实现可选匹配"><a href="#用问号实现可选匹配" class="headerlink" title="用问号实现可选匹配"></a>用问号实现可选匹配</h2><p>有时候，想匹配的模式是可选的。就是说，不论这段文本在不在，正则表达式都会认为匹配。字符?表明它前面的分组在这个模式中是可选的。例如，在交互式环境中输入以下代码：</p><pre><code>&gt;&gt;&gt; batRegex = re.compile(r&#39;Bat(wo)?man&#39;)&gt;&gt;&gt; mo1 = batRegex.search(&#39;The Adventures of Batman&#39;)&gt;&gt;&gt; mo1.group()&#39;Batman&#39;&gt;&gt;&gt; mo2 = batRegex.search(&#39;The Adventures of Batwoman&#39;)&gt;&gt;&gt; mo2.group()&#39;Batwoman&#39;</code></pre><p>你可以认为?是在说，“匹配这个问号之前的分组零次或一次”。</p><h2 id="用星号匹配零次或多次"><a href="#用星号匹配零次或多次" class="headerlink" title="用星号匹配零次或多次"></a>用星号匹配零次或多次</h2><p>*（称为星号）意味着“匹配零次或多次”，即星号之前的分组，可以在文本中出现任意次。它可以完全不存在，或一次又一次地重复。让我们再来看看 Batman 的例子。</p><pre><code>&gt;&gt;&gt; batRegex = re.compile(r&#39;Bat(wo)*man&#39;)&gt;&gt;&gt; mo1 = batRegex.search(&#39;The Adventures of Batman&#39;)&gt;&gt;&gt; mo1.group()&#39;Batman&#39;&gt;&gt;&gt; mo2 = batRegex.search(&#39;The Adventures of Batwoman&#39;)&gt;&gt;&gt; mo2.group()&#39;Batwoman&#39;&gt;&gt;&gt; mo3 = batRegex.search(&#39;The Adventures of Batwowowowoman&#39;)&gt;&gt;&gt; mo3.group()&#39;Batwowowowoman&#39;</code></pre><p>对于’Batman’，正则表达式的(wo)<em>部分匹配 wo 的零个实例。对于’Batwoman’，(wo)</em>匹配 wo 的一个实例。对于’Batwowowowoman’，(wo)*匹配 wo 的 4 个实例。</p><h2 id="用加号匹配一次或多次"><a href="#用加号匹配一次或多次" class="headerlink" title="用加号匹配一次或多次"></a>用加号匹配一次或多次</h2><p>*意味着“匹配零次或多次”，+（加号）则意味着“匹配一次或多次”。星号不要求分组出现在匹配的字符串中，但加号不同，加号前面的分组必须“至少出现一次”。</p><pre><code>&gt;&gt;&gt; batRegex = re.compile(r&#39;Bat(wo)+man&#39;)&gt;&gt;&gt; mo1 = batRegex.search(&#39;The Adventures of Batwoman&#39;)&gt;&gt;&gt; mo1.group()&#39;Batwoman&#39;&gt;&gt;&gt; mo2 = batRegex.search(&#39;The Adventures of Batwowowowoman&#39;)&gt;&gt;&gt; mo2.group()&#39;Batwowowowoman&#39;&gt;&gt;&gt; mo3 = batRegex.search(&#39;The Adventures of Batman&#39;)&gt;&gt;&gt; mo3 == NoneTrue</code></pre><h2 id="用花括号匹配特定次数"><a href="#用花括号匹配特定次数" class="headerlink" title="用花括号匹配特定次数"></a>用花括号匹配特定次数</h2><p>正则表达式(Ha){3}将匹配字符串’HaHaHa’，但不会匹配’HaHa’，因为后者只重复了(Ha)分组两次。 除了一个数字，还可以指定一个范围，即在花括号中写下一个最小值、一个逗号和一个最大值。例如，正则表达式(Ha){3,5}将匹配’HaHaHa’、’HaHaHaHa’和’HaHaHaHaHa’。 也可以不写花括号中的第一个或第二个数字，不限定最小值或最大值。例如， (Ha){3,}将匹配 3 次或更多次实例，(Ha){,5}将匹配 0 到 5 次实例。</p><pre><code>&gt;&gt;&gt; haRegex = re.compile(r&#39;(Ha){3}&#39;)&gt;&gt;&gt; mo1 = haRegex.search(&#39;HaHaHa&#39;)&gt;&gt;&gt; mo1.group()&#39;HaHaHa&#39;&gt;&gt;&gt; mo2 = haRegex.search(&#39;Ha&#39;)&gt;&gt;&gt; mo2 == NoneTrue </code></pre><p>这里，(Ha){3}匹配’HaHaHa’，但不匹配’Ha’。因为它不匹配’Ha’，所以 search()返回 None。</p><h2 id="贪心和非贪心匹配"><a href="#贪心和非贪心匹配" class="headerlink" title="贪心和非贪心匹配"></a>贪心和非贪心匹配</h2><p>在字符串’HaHaHaHaHa’中，因为(Ha){3,5}可以匹配 3 个、4 个或 5 个实例，你可能会想，为什么在前面花括号的例子中，Match 对象的 group()调用会返回’HaHaHaHaHa’，而不是更短的可能结果。毕竟，’HaHaHa’和’HaHaHaHa’也能够有效地匹配正则表达式(Ha){3,5}。 Python 的正则表达式默认是“贪心”的，这表示在有二义的情况下，它们会尽可能匹配最长的字符串。花括号的“非贪心”版本匹配尽可能最短的字符串，即在结束的花括号后跟着一个问号。 在交互式环境中输入以下代码，注意在查找相同字符串时，花括号的贪心形式和非贪心形式之间的区别：</p><pre><code>&gt;&gt;&gt; greedyHaRegex = re.compile(r&#39;(Ha){3,5}&#39;)&gt;&gt;&gt; mo1 = greedyHaRegex.search(&#39;HaHaHaHaHa&#39;)&gt;&gt;&gt; mo1.group()&#39;HaHaHaHaHa&#39;&gt;&gt;&gt; nongreedyHaRegex = re.compile(r&#39;(Ha){3,5}?&#39;)&gt;&gt;&gt; mo2 = nongreedyHaRegex.search(&#39;HaHaHaHaHa&#39;)&gt;&gt;&gt; mo2.group()&#39;HaHaHa&#39; </code></pre><p>请注意，问号在正则表达式中可能有两种含义：声明非贪心匹配或表示可选的分组。这两种含义是完全无关的。</p><h2 id="findall-方法"><a href="#findall-方法" class="headerlink" title="findall()方法"></a>findall()方法</h2><p>findall()方法返回一个字符串列表，只要在正则表达式中没有分组。列表中的每个字符串都是一段被查找的文本，它匹配该正则表达式。在交互式环境中输入以下代码：</p><pre><code>&gt;&gt;&gt; phoneNumRegex = re.compile(r&#39;ddd-ddd-dddd&#39;) # has no groups&gt;&gt;&gt; phoneNumRegex.findall(&#39;Cell: 415-555-9999 Work: 212-555-0000&#39;)[&#39;415-555-9999&#39;, &#39;212-555-0000&#39;]</code></pre><p>如果在正则表达式中有分组，那么 findall 将返回元组的列表。每个元组表示一个找到的匹配，其中的项就是正则表达式中每个分组的匹配字符串。为了看看 findall()的效果，请在交互式环境中输入以下代码（请注意，被编译的正则表达式现在有括号分组）：</p><pre><code>&gt;&gt;&gt; phoneNumRegex = re.compile(r&#39;(ddd)-(ddd)-(dddd)&#39;) # has groups&gt;&gt;&gt; phoneNumRegex.findall(&#39;Cell: 415-555-9999 Work: 212-555-0000&#39;)[(&#39;415&#39;, &#39;555&#39;, &#39;1122&#39;), (&#39;212&#39;, &#39;555&#39;, &#39;0000&#39;)] </code></pre><p>作为 findall()方法的返回结果的总结，请记住下面两点：</p><ol><li>如果调用在一个没有分组的正则表达式上，例如ddd-ddd-dddd，方法 findall()将返回一个匹配字符串的列表，例如[‘415-555-9999’, ‘212-555-0000’]。</li><li>如果调用在一个有分组的正则表达式上，例如(ddd)-(ddd)-(dddd)，方 法 findall()将返回一个字符串的元组的列表（每个分组对应一个字符串），例如[(‘415’, ‘555’, ‘1122’), (‘212’, ‘555’, ‘0000’)]。</li></ol><h2 id="字符分类"><a href="#字符分类" class="headerlink" title="字符分类"></a>字符分类</h2><blockquote><p>d 0 到 9 的任何数字 D 除 0 到 9 的数字以外的任何字符 w 任何字母、数字或下划线字符（可以认为是匹配“单词”字符） W 除字母、数字和下划线以外的任何字符 s 空格、制表符或换行符（可以认为是匹配“空白”字符） S 除空格、制表符和换行符以外的任何字符</p><pre><code>&gt;&gt; xmasRegex = re.compile(r&#39;d+sw+&#39;)&gt;&gt; xmasRegex.findall(&#39;12 drummers, 11 pipers, 10 lords, 9 ladies, 8 maids, 7swans, 6 geese, 5 rings, 4 birds, 3 hens, 2 doves, 1 partridge&#39;)[&#39;12 drummers&#39;, &#39;11 pipers&#39;, &#39;10 lords&#39;, &#39;9 ladies&#39;, &#39;8 maids&#39;, &#39;7 swans&#39;, &#39;6geese&#39;, &#39;5 rings&#39;, &#39;4 birds&#39;, &#39;3 hens&#39;, &#39;2 doves&#39;, &#39;1 partridge&#39;]</code></pre><p>正则表达式d+sw+匹配的文本有一个或多个数字(d+)，接下来是一个空白字符(s)，接下来是一个或多个字母/数字/下划线字符(w+)。findall()方法将返回所有匹配该正则表达式的字符串，放在一个列表中。</p></blockquote><h2 id="建立自己的字符分类"><a href="#建立自己的字符分类" class="headerlink" title="建立自己的字符分类"></a>建立自己的字符分类</h2><p>有时候你想匹配一组字符，但缩写的字符分类（d、w、s 等）太宽泛。你可以用方括号定义自己的字符分类。例如，字符分类[aeiouAEIOU]将匹配所有元音字符，不论大小写。在交互式环境中输入以下代码：</p><pre><code>&gt;&gt;&gt; vowelRegex = re.compile(r&#39;[aeiouAEIOU]&#39;)&gt;&gt;&gt; vowelRegex.findall(&#39;RoboCop eats baby food. BABY FOOD.&#39;)[&#39;o&#39;, &#39;o&#39;, &#39;o&#39;, &#39;e&#39;, &#39;a&#39;, &#39;a&#39;, &#39;o&#39;, &#39;o&#39;, &#39;A&#39;, &#39;O&#39;, &#39;O&#39;] </code></pre><p>也可以使用短横表示字母或数字的范围。例如，字符分类[a-zA-Z0-9]将匹配所有小写字母、大写字母和数字。 请注意，在方括号内，普通的正则表达式符号不会被解释。这意味着，你不需要前面加上倒斜杠转义.、*、?或()字符。例如，字符分类将匹配数字 0 到 5 和一个句点。你不需要将它写成[0-5.]。 通过在字符分类的左方括号后加上一个插入字符（^），就可以得到“非字符类”。非字符类将匹配不在这个字符类中的所有字符。例如，在交互式环境中输入以下代码：</p><pre><code>&gt;&gt;&gt; consonantRegex = re.compile(r&#39;[^aeiouAEIOU]&#39;)&gt;&gt;&gt; consonantRegex.findall(&#39;RoboCop eats baby food. BABY FOOD.&#39;)[&#39;R&#39;, &#39;b&#39;, &#39;c&#39;, &#39;p&#39;, &#39; &#39;, &#39;t&#39;, &#39;s&#39;, &#39; &#39;, &#39;b&#39;, &#39;b&#39;, &#39;y&#39;, &#39; &#39;, &#39;f&#39;, &#39;d&#39;, &#39;.&#39;, &#39;&#39;, &#39;B&#39;, &#39;B&#39;, &#39;Y&#39;, &#39; &#39;, &#39;F&#39;, &#39;D&#39;, &#39;.&#39;]</code></pre><p>现在，不是匹配所有元音字符，而是匹配所有非元音字符。</p><h2 id="插入字符和美元字符"><a href="#插入字符和美元字符" class="headerlink" title="插入字符和美元字符"></a>插入字符和美元字符</h2><ul><li>（^），表明匹配必须发生在被查找文本开始处。</li><li>（$），表示该字符串必须以这个正则表达式的模式结束。</li></ul><p>可以同时使用^和$，表明整个字符串必须匹配该模式，也就是说，只匹配该字符串的某个子集是不够的。正则表达式 r’^Hello’匹配以’Hello’开始的字符串。在交互式环境中输入以下代码：</p><pre><code>&gt;&gt;&gt; beginsWithHello = re.compile(r&#39;^Hello&#39;)&gt;&gt;&gt; beginsWithHello.search(&#39;Hello world!&#39;)&lt;_sre.SRE_Match object; span=(0, 5), match=&#39;Hello&#39;&gt;&gt;&gt;&gt; beginsWithHello.search(&#39;He said hello.&#39;) == NoneTrue</code></pre><p>正则表达式 r’d$’匹配以数字 0 到 9 结束的字符串。在交互式环境中输入以下代码：</p><pre><code>&gt;&gt;&gt; endsWithNumber = re.compile(r&#39;d$&#39;)&gt;&gt;&gt; endsWithNumber.search(&#39;Your number is 42&#39;)&lt;_sre.SRE_Match object; span=(16, 17), match=&#39;2&#39;&gt;</code></pre><p>正则表达式 r’^d+$’匹配从开始到结束都是数字的字符串。在交互式环境中输入以下代码：</p><pre><code>&gt;&gt;&gt; wholeStringIsNum = re.compile(r&#39;^d+$&#39;)&gt;&gt;&gt; wholeStringIsNum.search(&#39;1234567890&#39;)&lt;_sre.SRE_Match object; span=(0, 10), match=&#39;1234567890&#39;&gt;&gt;&gt;&gt; wholeStringIsNum.search(&#39;12345xyz67890&#39;) == NoneTrue&gt;&gt;&gt; wholeStringIsNum.search(&#39;12 34567890&#39;) == NoneTrue</code></pre><p>前面交互式脚本例子中的最后两次 search()调用表明，如果使用了^和$，那么整个字符串必须匹配该正则表达式。</p><h2 id="通配字符"><a href="#通配字符" class="headerlink" title="通配字符"></a>通配字符</h2><p>在正则表达式中，.（句点）字符称为“通配符”。它匹配除了换行之外的所有字符。例如，在交互式环境中输入以下代码：</p><pre><code>&gt;&gt;&gt; atRegex = re.compile(r&#39;.at&#39;)&gt;&gt;&gt; atRegex.findall(&#39;The cat in the hat sat on the flat mat.&#39;)[&#39;cat&#39;, &#39;hat&#39;, &#39;sat&#39;, &#39;lat&#39;, &#39;mat&#39;]</code></pre><p>要记住，句点字符只匹配一个字符</p><h2 id="用点-星匹配所有字符"><a href="#用点-星匹配所有字符" class="headerlink" title="用点-星匹配所有字符"></a>用点-星匹配所有字符</h2><p>句点字符表示“除换行外所有单个字符”，星号字符表示“前面字符出现零次或多次”。在交互式环境中输入以下代码：</p><pre><code>&gt;&gt;&gt; nameRegex = re.compile(r&#39;First Name: (.*) Last Name: (.*)&#39;)&gt;&gt;&gt; mo = nameRegex.search(&#39;First Name: Al Last Name: Sweigart&#39;)&gt;&gt;&gt; mo.group(1)&#39;Al&#39;&gt;&gt;&gt; mo.group(2)&#39;Sweigart&#39;</code></pre><p>点-星使用“贪心”模式：它总是匹配尽可能多的文本。要用“非贪心”模式匹配所有文本，就使用点-星和问号。</p><pre><code>&gt;&gt;&gt; nongreedyRegex = re.compile(r&#39;&lt;.*?&gt;&#39;)&gt;&gt;&gt; mo = nongreedyRegex.search(&#39;&lt;To serve man&gt; for dinner.&gt;&#39;)&gt;&gt;&gt; mo.group()&#39;&lt;To serve man&gt;&#39;&gt;&gt;&gt; greedyRegex = re.compile(r&#39;&lt;.*&gt;&#39;)&gt;&gt;&gt; mo = greedyRegex.search(&#39;&lt;To serve man&gt; for dinner.&gt;&#39;)&gt;&gt;&gt; mo.group()&#39;&lt;To serve man&gt; for dinner.&gt;&#39;</code></pre><p>两个正则表达式都可以翻译成“匹配一个左尖括号，接下来是任意字符，接下来是一个右尖括号”。但是字符串’ for dinner.&gt;’对右肩括号有两种可能的匹配。在非贪心的正则表达式中，Python 匹配最短可能的字符串：’’。在贪心版本中，Python 匹配最长可能的字符串：’ for dinner.&gt;’。</p><h2 id="用句点字符匹配换行"><a href="#用句点字符匹配换行" class="headerlink" title="用句点字符匹配换行"></a>用句点字符匹配换行</h2><p>点-星将匹配除换行外的所有字符。通过传入 re.DOTALL 作为 re.compile()的第二个参数，可以让句点字符匹配所有字符，包括换行字符。</p><pre><code>&gt;&gt;&gt; noNewlineRegex = re.compile(&#39;.*&#39;)&gt;&gt;&gt; noNewlineRegex.search(&#39;Serve the public trust.nProtect the innocent.nUphold the law.&#39;).group()&#39;Serve the public trust.&#39;&gt;&gt;&gt; newlineRegex = re.compile(&#39;.*&#39;, re.DOTALL)&gt;&gt;&gt; newlineRegex.search(&#39;Serve the public trust.nProtect the innocent.nUphold the law.&#39;).group()&#39;Serve the public trust.nProtect the innocent.nUphold the law.&#39;</code></pre><h2 id="不区分大小写的匹配"><a href="#不区分大小写的匹配" class="headerlink" title="不区分大小写的匹配"></a>不区分大小写的匹配</h2><p>要让正则表达式不区分大小写，可以向 re.compile()传入 re.IGNORECASE 或 re.I，作为第二个参数。 在交互式环境中输入以下代码：</p><pre><code>&gt;&gt;&gt; robocop = re.compile(r&#39;robocop&#39;, re.I)&gt;&gt;&gt; robocop.search(&#39;RoboCop is part man, part machine, all cop.&#39;).group()&#39;RoboCop&#39;&gt;&gt;&gt; robocop.search(&#39;ROBOCOP protects the innocent.&#39;).group()&#39;ROBOCOP&#39; </code></pre><h2 id="用-sub-方法替换字符串"><a href="#用-sub-方法替换字符串" class="headerlink" title="用 sub()方法替换字符串"></a>用 sub()方法替换字符串</h2><p>第一个参数是一个字符串，用于取代发现的匹配。第二个参数是一个字符串，即正则表达式。sub()方法返回替换完成后的字符串。例如，在交互式环境中输入以下代码：</p><pre><code>&gt;&gt;&gt; namesRegex = re.compile(r&#39;Agent w+&#39;)&gt;&gt;&gt; namesRegex.sub(&#39;CENSORED&#39;, &#39;Agent Alice gave the secret documents to Agent Bob.&#39;)&#39;CENSORED gave the secret documents to CENSORED.&#39;</code></pre><p>有时候，你可能需要使用匹配的文本本身，作为替换的一部分。在 sub()的第一个参数中，可以输入1、2、3……。表示“在替换中输入分组 1、2、3……的文本”。 例如，假定想要隐去密探的姓名，只显示他们姓名的第一个字母。要做到这一点，可以使用正则表达式 Agent (w)w<em>，传入 r’1<em>*</em></em>‘作为 sub()的第一个参数。字符串中的1 将由分组 1 匹配的文本所替代，也就是正则表达式的(w)分组。</p><pre><code>&gt;&gt;&gt; agentNamesRegex = re.compile(r&#39;Agent (w)w*&#39;)&gt;&gt;&gt; agentNamesRegex.sub(r&#39;1****&#39;, &#39;Agent Alice told Agent Carol that AgentEve knew Agent Bob was a double agent.&#39;)A**** told C**** that E**** knew B**** was a double agent.&#39;</code></pre><h2 id="管理复杂的正则表达式"><a href="#管理复杂的正则表达式" class="headerlink" title="管理复杂的正则表达式"></a>管理复杂的正则表达式</h2><p>忽略正则表达式字符串中的空白符和注释，可以向 re.compile()传入变量 re.VERBOSE，作为第二个参数。</p><pre><code>phoneRegex = re.compile(r&#39;&#39;&#39;( (d{3}|(d{3}))? # area code (s|-|.)? # separator d{3} # first 3 digits (s|-|.) # separator d{4} # last 4 digits (s*(ext|x|ext.)s*d{2,5})? # extension )&#39;&#39;&#39;, re.VERBOSE)</code></pre><p>请注意，前面的例子使用了三重引号(‘“)，创建了一个多行字符串。这样就可以将正则表达式定义放在多行中，让它更可读。</p><h2 id="组合使用-re-IGNOREC-ASE、re-DOTALL-和-re-VERBOSE"><a href="#组合使用-re-IGNOREC-ASE、re-DOTALL-和-re-VERBOSE" class="headerlink" title="组合使用 re.IGNOREC ASE、re.DOTALL 和 re.VERBOSE"></a>组合使用 re.IGNOREC ASE、re.DOTALL 和 re.VERBOSE</h2><p>可以使用管道字符（|）将变量组合起来，从而绕过这个限制。管道字符在这里称为“按位或”操作符。所以，如果希望正则表达式不区分大小写，并且句点字符匹配换行，就可以这样构造 re.compile()调用：</p><pre><code>&gt;&gt;&gt; someRegexValue = re.compile(&#39;foo&#39;, re.IGNORECASE | re.DOTALL)</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模块 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
